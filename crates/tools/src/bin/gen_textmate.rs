//! Generator for VSCode TextMate grammar from CDSL lexer definitions.
//!
//! This tool generates `tools/vscode-cdsl/syntaxes/cdsl.tmLanguage.json`
//! from the authoritative token definitions in the lexer.
//!
//! Run with: `cargo run --bin gen-textmate`
//!
//! The grammar is structured to match:
//! - Declaration keywords (signal, field, etc.) followed by space + name
//! - Reference keywords (signal., const., etc.) followed by dot in expressions  
//! - Block keywords (resolve, measure, etc.)
//! - Operators and punctuation
//! - Literals (numbers, strings, booleans)
//! - Comments (line, block, doc)

use serde_json::{Value, json};
use std::fs;
use std::path::PathBuf;

/// Declaration keywords - these start top-level items: `keyword name.path {}`
const DECLARATION_KEYWORDS: &[(&str, &str)] = &[
    ("signal", "signal"),
    ("field", "field"),
    ("operator", "operator"),
    ("fracture", "fracture"),
    ("impulse", "impulse"),
    ("chronicle", "chronicle"),
    ("entity", "entity"),
    ("member", "member"),
    ("strata", "strata"),
    ("era", "era"),
    ("type", "type"),
    ("fn", "function"),
    ("world", "world"),
];

/// Reference keywords - these are used in expressions: `keyword.path`
const REFERENCE_KEYWORDS: &[(&str, &str)] = &[
    ("signal", "signal"),
    ("const", "const"),
    ("config", "config"),
    ("field", "field"),
    ("entity", "entity"),
];

/// Block keywords - used inside definition bodies
const BLOCK_KEYWORDS: &[&str] = &[
    "resolve",
    "measure",
    "when",
    "emit",
    "assert",
    "collect",
    "on",
    "config",
    "initial",
    "terminal",
    "transition",
];

/// Control flow keywords
const CONTROL_KEYWORDS: &[&str] = &["if", "else", "let", "in", "for"];

/// Language variables (special identifiers)
const LANGUAGE_VARIABLES: &[&str] = &["prev", "dt_raw", "collected", "payload", "self"];

/// Logical keyword operators
const LOGICAL_KEYWORDS: &[&str] = &["and", "or", "not"];

/// Aggregate operators
const AGGREGATE_KEYWORDS: &[&str] = &[
    "sum", "count", "product", "min", "max", "mean", "any", "all", "none",
];

/// Entity query operators
const ENTITY_KEYWORDS: &[&str] = &[
    "other", "pairs", "filter", "first", "nearest", "within", "each",
];

/// Math constants
const MATH_CONSTANTS: &[&str] = &["PI", "TAU", "PHI", "E", "I"];

/// Severity keywords (for assertions)
const SEVERITY_KEYWORDS: &[&str] = &["warn", "error", "halt", "fatal"];

/// Attribute keywords (after colon in definitions)
const ATTRIBUTE_KEYWORDS: &[&str] = &[
    "strata", "topology", "title", "symbol", "uses", "phase", "era", "stride", "active",
    "converge", "warmup", "iterate", "gated",
];

/// Built-in type names
const TYPE_NAMES: &[&str] = &[
    "Scalar",
    "Vector",
    "Tensor",
    "Map",
    "sphere_surface",
    "point_cloud",
    "volume",
    "symmetric",
    "positive_definite",
];

fn main() -> anyhow::Result<()> {
    let grammar = generate_grammar();

    // Find output path relative to workspace root
    let out_path = find_output_path()?;

    let json_str = serde_json::to_string_pretty(&grammar)?;
    fs::write(&out_path, json_str)?;

    println!("Generated: {}", out_path.display());
    Ok(())
}

fn find_output_path() -> anyhow::Result<PathBuf> {
    // Try to find workspace root by looking for Cargo.toml with [workspace]
    let mut dir = std::env::current_dir()?;
    loop {
        let cargo_toml = dir.join("Cargo.toml");
        if cargo_toml.exists() {
            let content = fs::read_to_string(&cargo_toml)?;
            if content.contains("[workspace]") {
                return Ok(dir.join("tools/vscode-cdsl/syntaxes/cdsl.tmLanguage.json"));
            }
        }
        if !dir.pop() {
            anyhow::bail!("Could not find workspace root");
        }
    }
}

fn generate_grammar() -> Value {
    // Build the terminator lookahead pattern for all declaration keywords
    let decl_terminators: Vec<String> = DECLARATION_KEYWORDS
        .iter()
        .map(|(kw, _)| format!("\\b{}\\b", kw))
        .chain(
            ["\\bconst\\b", "\\bconfig\\b"]
                .iter()
                .map(|s| s.to_string()),
        )
        .collect();
    let terminator_pattern = format!("(?={}|$(?!\\n))", decl_terminators.join("|"));

    json!({
        "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
        "name": "Continuum DSL",
        "scopeName": "source.cdsl",
        "fileTypes": ["cdsl"],
        "_generator": "Generated by gen-textmate. Do not edit manually.",
        "patterns": [
            { "include": "#comments" },
            { "include": "#top-level-items" },
            { "include": "#expressions" }
        ],
        "repository": {
            "comments": generate_comments(),
            "top-level-items": generate_top_level_items(),
            "const-block": generate_const_block(),
            "config-block": generate_config_block(),
            "const-entry": generate_const_entry(),
            "config-entry": generate_config_entry(),

            // Declaration definitions
            "signal-def": generate_declaration_def("signal", "signal", &terminator_pattern, false),
            "field-def": generate_declaration_def("field", "field", &terminator_pattern, false),
            "operator-def": generate_declaration_def("operator", "operator", &terminator_pattern, false),
            "fracture-def": generate_declaration_def("fracture", "fracture", &terminator_pattern, false),
            "impulse-def": generate_declaration_def("impulse", "impulse", &terminator_pattern, false),
            "chronicle-def": generate_declaration_def("chronicle", "chronicle", &terminator_pattern, false),
            "entity-def": generate_declaration_def("entity", "entity", &terminator_pattern, false),
            "member-def": generate_declaration_def("member", "member", &terminator_pattern, false),
            "strata-def": generate_declaration_def("strata", "strata", &terminator_pattern, false),
            "era-def": generate_declaration_def("era", "era", &terminator_pattern, false),
            "type-def": generate_declaration_def("type", "type", &terminator_pattern, false),
            "fn-def": generate_declaration_def("fn", "function", &terminator_pattern, true),
            "world-def": generate_declaration_def("world", "world", &terminator_pattern, false),

            "fn-name-and-params": generate_fn_name_and_params(),
            "definition-name": generate_definition_name(),
            "definition-body": generate_definition_body(),
            "block-keywords": generate_block_keywords(),
            "attributes": generate_attributes(),
            "inner-blocks": generate_inner_blocks(),
            "expressions": generate_expressions(),
            "keywords": generate_keywords(),
            "operators": generate_operators(),
            "references": generate_references(),
            "function-calls": generate_function_calls(),
            "literals": generate_literals(),
            "identifiers": generate_identifiers(),
        }
    })
}

fn generate_comments() -> Value {
    json!({
        "patterns": [
            {
                "name": "comment.line.documentation.cdsl",
                "match": "///.*$"
            },
            {
                "name": "comment.line.module-documentation.cdsl",
                "match": "//!.*$"
            },
            {
                "name": "comment.line.double-slash.cdsl",
                "match": "//.*$"
            },
            {
                "name": "comment.line.hash.cdsl",
                "match": "#.*$"
            },
            {
                "name": "comment.block.cdsl",
                "begin": "/\\*",
                "end": "\\*/",
                "captures": {
                    "0": { "name": "punctuation.definition.comment.cdsl" }
                }
            }
        ]
    })
}

fn generate_top_level_items() -> Value {
    let mut patterns = vec![
        json!({ "include": "#const-block" }),
        json!({ "include": "#config-block" }),
    ];

    for (keyword, _) in DECLARATION_KEYWORDS {
        patterns.push(json!({ "include": format!("#{}-def", keyword) }));
    }

    json!({ "patterns": patterns })
}

fn generate_const_block() -> Value {
    json!({
        "begin": "\\b(const)\\s*\\{",
        "end": "\\}",
        "beginCaptures": {
            "1": { "name": "keyword.other.const.cdsl" }
        },
        "patterns": [
            { "include": "#comments" },
            { "include": "#const-entry" }
        ]
    })
}

fn generate_config_block() -> Value {
    json!({
        "begin": "\\b(config)\\s*\\{",
        "end": "\\}",
        "beginCaptures": {
            "1": { "name": "keyword.other.config.cdsl" }
        },
        "patterns": [
            { "include": "#comments" },
            { "include": "#config-entry" }
        ]
    })
}

fn generate_const_entry() -> Value {
    json!({
        "match": "([a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*)\\s*(:)\\s*([^\\n#/]+)",
        "captures": {
            "1": { "name": "variable.other.constant.cdsl" },
            "2": { "name": "punctuation.separator.cdsl" },
            "3": { "patterns": [{ "include": "#literals" }] }
        }
    })
}

fn generate_config_entry() -> Value {
    json!({
        "match": "([a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*)\\s*(:)\\s*([^\\n#/]+)",
        "captures": {
            "1": { "name": "variable.other.config.cdsl" },
            "2": { "name": "punctuation.separator.cdsl" },
            "3": { "patterns": [{ "include": "#literals" }] }
        }
    })
}

fn generate_declaration_def(
    keyword: &str,
    scope_name: &str,
    terminator: &str,
    is_fn: bool,
) -> Value {
    let patterns = if is_fn {
        vec![
            json!({ "include": "#comments" }),
            json!({ "include": "#fn-name-and-params" }),
            json!({ "include": "#definition-body" }),
        ]
    } else {
        vec![
            json!({ "include": "#comments" }),
            json!({ "include": "#definition-name" }),
            json!({ "include": "#definition-body" }),
        ]
    };

    json!({
        "begin": format!("\\b({})\\s+", keyword),
        "end": terminator,
        "beginCaptures": {
            "1": { "name": format!("keyword.declaration.{}.cdsl", scope_name) }
        },
        "patterns": patterns
    })
}

fn generate_fn_name_and_params() -> Value {
    json!({
        "begin": "([a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*)\\s*(\\()",
        "end": "(\\))",
        "beginCaptures": {
            "1": { "name": "entity.name.function.cdsl" },
            "2": { "name": "punctuation.parenthesis.open.cdsl" }
        },
        "endCaptures": {
            "1": { "name": "punctuation.parenthesis.close.cdsl" }
        },
        "patterns": [
            { "include": "#comments" },
            {
                "match": "([a-zA-Z_][a-zA-Z0-9_]*)",
                "name": "variable.parameter.cdsl"
            },
            {
                "match": ",",
                "name": "punctuation.separator.cdsl"
            }
        ]
    })
}

fn generate_definition_name() -> Value {
    json!({
        "match": "([a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*)",
        "captures": {
            "1": { "name": "entity.name.cdsl" }
        }
    })
}

fn generate_definition_body() -> Value {
    json!({
        "begin": "\\{",
        "end": "\\}",
        "beginCaptures": {
            "0": { "name": "punctuation.brace.open.cdsl" }
        },
        "endCaptures": {
            "0": { "name": "punctuation.brace.close.cdsl" }
        },
        "patterns": [
            { "include": "#comments" },
            { "include": "#block-keywords" },
            { "include": "#attributes" },
            { "include": "#inner-blocks" },
            { "include": "#expressions" }
        ]
    })
}

fn generate_block_keywords() -> Value {
    let pattern = format!("\\b({})\\b", BLOCK_KEYWORDS.join("|"));
    json!({
        "match": pattern,
        "name": "keyword.control.block.cdsl"
    })
}

fn generate_attributes() -> Value {
    let type_pattern = TYPE_NAMES.join("|");
    let attr_pattern = ATTRIBUTE_KEYWORDS.join("|");

    json!({
        "patterns": [
            {
                "match": format!("(:)\\s*({})\\b", type_pattern),
                "captures": {
                    "1": { "name": "punctuation.separator.cdsl" },
                    "2": { "name": "support.type.cdsl" }
                }
            },
            {
                "match": format!("(:)\\s*({})\\s*(\\()", attr_pattern),
                "captures": {
                    "1": { "name": "punctuation.separator.cdsl" },
                    "2": { "name": "keyword.attribute.cdsl" },
                    "3": { "name": "punctuation.parenthesis.open.cdsl" }
                }
            },
            {
                "match": "(:)\\s*(initial|terminal)\\b",
                "captures": {
                    "1": { "name": "punctuation.separator.cdsl" },
                    "2": { "name": "keyword.attribute.cdsl" }
                }
            }
        ]
    })
}

fn generate_inner_blocks() -> Value {
    let block_pattern = BLOCK_KEYWORDS
        .iter()
        .filter(|&&k| k != "initial" && k != "terminal" && k != "on")
        .cloned()
        .collect::<Vec<_>>()
        .join("|");

    json!({
        "begin": format!("\\b({})\\s*\\{{", block_pattern),
        "end": "\\}",
        "beginCaptures": {
            "1": { "name": "keyword.control.block.cdsl" }
        },
        "patterns": [
            { "include": "#comments" },
            { "include": "#expressions" },
            { "include": "#inner-blocks" }
        ]
    })
}

fn generate_expressions() -> Value {
    json!({
        "patterns": [
            { "include": "#comments" },
            { "include": "#keywords" },
            { "include": "#operators" },
            { "include": "#references" },
            { "include": "#function-calls" },
            { "include": "#literals" },
            { "include": "#identifiers" }
        ]
    })
}

fn generate_keywords() -> Value {
    let control_pattern = CONTROL_KEYWORDS.join("|");
    let lang_vars = LANGUAGE_VARIABLES
        .iter()
        .filter(|&&v| v != "self")
        .cloned()
        .collect::<Vec<_>>()
        .join("|");
    let logical_pattern = LOGICAL_KEYWORDS.join("|");
    let aggregate_pattern = AGGREGATE_KEYWORDS.join("|");
    let entity_pattern = ENTITY_KEYWORDS.join("|");
    let math_pattern = MATH_CONSTANTS.join("|");
    let severity_pattern = SEVERITY_KEYWORDS.join("|");

    json!({
        "patterns": [
            {
                "match": format!("\\b({})\\b", control_pattern),
                "name": "keyword.control.cdsl"
            },
            {
                "match": format!("\\b({})\\b", lang_vars),
                "name": "variable.language.cdsl"
            },
            {
                "match": "\\b(self)\\b",
                "name": "variable.language.self.cdsl"
            },
            {
                "match": format!("\\b({})\\b", logical_pattern),
                "name": "keyword.operator.logical.cdsl"
            },
            {
                "match": format!("\\b({})\\b", aggregate_pattern),
                "name": "keyword.operator.aggregate.cdsl"
            },
            {
                "match": format!("\\b({})\\b", entity_pattern),
                "name": "keyword.operator.entity.cdsl"
            },
            {
                "match": format!("\\b({})\\b|[\u{03C0}\u{03C4}\u{03C6}\u{212F}\u{2148}]", math_pattern),
                "name": "constant.language.math.cdsl"
            },
            {
                "match": format!("\\b({})\\b", severity_pattern),
                "name": "keyword.other.severity.cdsl"
            }
        ]
    })
}

fn generate_operators() -> Value {
    json!({
        "patterns": [
            {
                "match": "<-",
                "name": "keyword.operator.assignment.cdsl"
            },
            {
                "match": "==|!=|<=|>=|<|>",
                "name": "keyword.operator.comparison.cdsl"
            },
            {
                "match": "&&|\\|\\|",
                "name": "keyword.operator.logical.cdsl"
            },
            {
                "match": "\\+|-|\\*|/|%|\\^",
                "name": "keyword.operator.arithmetic.cdsl"
            },
            {
                "match": "!",
                "name": "keyword.operator.logical.not.cdsl"
            },
            {
                "match": "\\.\\.",
                "name": "keyword.operator.range.cdsl"
            }
        ]
    })
}

fn generate_references() -> Value {
    let patterns: Vec<Value> = REFERENCE_KEYWORDS
        .iter()
        .map(|(keyword, scope)| {
            json!({
                "match": format!("\\b({})(\\.)", keyword),
                "captures": {
                    "1": { "name": format!("keyword.other.reference.{}.cdsl", scope) },
                    "2": { "name": "punctuation.accessor.cdsl" }
                }
            })
        })
        .collect();

    json!({ "patterns": patterns })
}

fn generate_function_calls() -> Value {
    json!({
        "patterns": [
            {
                "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*)\\s*(?=\\()",
                "captures": {
                    "1": { "name": "entity.name.function.call.cdsl" }
                }
            }
        ]
    })
}

fn generate_literals() -> Value {
    json!({
        "patterns": [
            {
                "name": "string.quoted.double.cdsl",
                "begin": "\"",
                "end": "\"",
                "patterns": [
                    {
                        "name": "constant.character.escape.cdsl",
                        "match": "\\\\."
                    }
                ]
            },
            {
                "match": "-?\\d+\\.\\d+([eE][+-]?\\d+)?",
                "name": "constant.numeric.float.cdsl"
            },
            {
                "match": "-?\\d+[eE][+-]?\\d+",
                "name": "constant.numeric.float.scientific.cdsl"
            },
            {
                "match": "-?\\d+",
                "name": "constant.numeric.integer.cdsl"
            },
            {
                "comment": "Unit annotation like <K>, <W/m\u{00B2}>, <kg/s> - no spaces allowed inside",
                "match": "<[a-zA-Z0-9/\u{00B7}\u{00B0}\u{2070}\u{00B9}\u{00B2}\u{00B3}\u{2074}\u{2075}\u{2076}\u{2077}\u{2078}\u{2079}\u{207B}\u{207A}_-]+>",
                "name": "support.type.unit.cdsl"
            }
        ]
    })
}

fn generate_identifiers() -> Value {
    json!({
        "match": "\\b[a-zA-Z_][a-zA-Z0-9_]*\\b",
        "name": "variable.other.cdsl"
    })
}
