// Realistic CDSL declarations testing parser robustness
// Includes comments, attributes, type annotations, and execution blocks

// ===== Type Definitions =====

type Position {
    x: Scalar<m>
    y: Scalar<m>
    z: Scalar<m>
}

type Velocity {
    vx: Scalar<m/s>
    vy: Scalar<m/s>
    vz: Scalar<m/s>
}

// ===== Config and Const =====

config {
    gravity: 9.81 <m/s/s>
    timestep: 0.001 <s>
    max_iterations: 1000
}

const {
    SPEED_OF_LIGHT: 299792458.0 <m/s>
    BOLTZMANN: 1.380649e-23 <J/K>
}

// ===== Basic Entity (members removed - not yet supported in parser) =====

entity :stratum("fast") particle

// ===== Signals with Multiple Phases =====

signal :stratum("default") global_temperature : Scalar<K> {
    initial {
        300.0 <K>
    }
    
    collect {
        // Accumulate temperature from all entities
        agg.mean(entity.particle, signal.temperature)
    }
    
    resolve {
        // Validate temperature range
        assert self > 0.0 <K> message "Temperature must be positive"
        assert self < 1e6 <K> severity "error"
        
        // Apply damping
        self * 0.99
    }
}

// ===== Field with Comments =====

field :stratum("visual") heat_map : Scalar<K> {
    // This field provides a spatial heat distribution
    // for visualization purposes only
    measure {
        let nearest_entity = nearest(entity.particle, self.position)
        signal.temperature
    }
}

// ===== Operator with Complex Logic =====

operator :stratum("fast") thermal_transfer {
    resolve {
        // For each pair of nearby particles
        let pairs = pairs(entity.particle)
        
        // Calculate heat transfer
        let distance = signal.position_a.sub(signal.position_b).magnitude()
        let temp_diff = signal.temp_a - signal.temp_b
        
        // Simplified heat transfer calculation
        let heat_flow = if distance > 0.0 <m> {
            const.BOLTZMANN * temp_diff / distance
        } else {
            0.0 <W>
        }
        
        emit(signal.heat_transfer_rate, heat_flow)
    }
}

// Note: impulse and fracture blocks removed - content parsing not yet implemented
// These will be added once parser supports their internal syntax
