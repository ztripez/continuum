# Terra Geophysics Simulation
# Implements realistic crust dynamics with isostasy and dynamic topography
# to stress-test the bytecode VM with complex mathematical expressions
#
# SHOWCASES: Unicode unit superscripts (kg/m³, m/s², W/m², N/m², etc.)
# NOTE: this is should be a recration of oldreference-project/crates/domains/terra/src/geophysics/crust.rs
# =============================================================================
# User-Defined Functions
# =============================================================================

# Compute isostatic buoyancy factor from density contrast
fn.isostasy.buoyancy_factor(crustal_density, mantle_density) {
    1.0 - crustal_density / mantle_density
}

# Compute isostatic elevation from thickness, factor, and reference level
fn.isostasy.compute_elevation(thickness, factor, reference_level) {
    factor * thickness - reference_level
}

# Compute lithostatic pressure at depth
fn.pressure.lithostatic(surface_pressure, density, gravity, depth) {
    surface_pressure + density * gravity * depth
}

# Compute geothermal temperature at depth
fn.thermal.geothermal_temp(surface_temp, gradient, depth_km) {
    surface_temp + gradient * depth_km
}

# =============================================================================
# Physical Constants
# =============================================================================

const {
    physics.gravitational: 6.67430e-11
    physics.stefan_boltzmann: 5.67e-8
    earth.mass: 5.972e24
    earth.radius: 6.371e6
    earth.gravity: 9.80665
    crust.density_continental: 2700.0
    mantle.density: 3300.0
    isostasy.reference_thickness: 35000.0
    topography.max_plume_uplift: 2000.0
    topography.max_slab_depression: 1000.0
    thermal.surface_temp: 288.0
    thermal.gradient: 25.0
    thermal.mantle_temp: 1600.0
}

# =============================================================================
# Configuration (scenario-overridable)
# =============================================================================

config {
    planet.mass: 5.972e24
    planet.radius: 6.371e6
    crust.initial_thickness: 35000.0
    crust.min_thickness: 3000.0
    crust.max_thickness: 80000.0
    crust.density: 2700.0
    isostasy.crustal_density: 2700.0
    isostasy.mantle_density: 3300.0
    topography.flow_coupling: 1.0
    elevation.max_depth: 11000.0
    elevation.max_height: 9000.0
    thermal.decay_halflife: 4.5e17 <s>
    thermal.surface_heat_flow: 0.065
    thermal.conductivity: 2.5

    # Initial values for signals (pattern: initial_<last_segment>)
    core.initial_temp: 5500.0
    mantle.initial_temp: 1600.0
    surface.initial_temp: 288.0
    surface.initial_heat_flow: 0.065
    crust.initial_density: 2700.0
    crust.initial_elevation: 0.0
    crust.initial_pressure_base: 1e9
    crust.initial_temp_base: 1163.0
    crust.initial_moho_depth: 35000.0
    isostasy.initial_factor: 0.182
    isostasy.initial_reference_level: 6370.0
    isostasy.initial_elevation: 0.0
    topography.initial_dynamic_offset: 0.0
    tectonics.initial_boundary_stress: 0.0
    planet.initial_radius: 6.371e6
    planet.initial_mass: 5.972e24
    planet.initial_gravity_mu: 3.986e14
    planet.initial_surface_gravity: 9.81
}

# =============================================================================
# Strata Definitions
# =============================================================================

strata.genesis {
    : title("Genesis")
    : symbol("G")
    : stride(1)
}

strata.tectonics {
    : title("Tectonics")
    : symbol("T")
    : stride(10)
}

strata.thermal {
    : title("Thermal")
    : symbol("Q")
    : stride(1)
}

# =============================================================================
# Era Definitions
# =============================================================================

era.formation {
    : initial
    : title("Planetary Formation")
    : dt(10 <Myr>)

    strata {
        genesis: active
        tectonics: active
        thermal: active
    }

    transition {
        to: era.active_tectonics
        when {
            signal.crust.total_thickness > 30000
        }
    }
}

era.active_tectonics {
    : title("Active Tectonics")
    : dt(1 <Myr>)

    strata {
        genesis: gated
        tectonics: active
        thermal: active
    }

    transition {
        to: era.cooling
        when {
            signal.core.temp < 4000 <K>
        }
    }
}

era.cooling {
    : terminal
    : title("Cooling Phase")
    : dt(100 <kyr>)

    strata {
        genesis: gated
        tectonics: gated
        thermal: active
    }
}

# =============================================================================
# Core Planetary Signals
# =============================================================================

signal.planet.radius {
    : Scalar<m, 1e6..1e8>
    : strata(genesis)
    : title("Planet Radius")
    : symbol("R")

    resolve {
        config.planet.radius
    }

    assert {
        prev >= 1e6 : fatal, "Planet radius below minimum"
        prev <= 1e8 : fatal, "Planet radius above maximum"
    }
}

signal.planet.mass {
    : Scalar<kg, 1e22..1e28>
    : strata(genesis)
    : title("Planet Mass")
    : symbol("M")

    resolve {
        config.planet.mass
    }

    assert {
        prev >= 1e22 : fatal, "Planet mass below minimum"
        prev <= 1e28 : fatal, "Planet mass above maximum"
    }
}

# Gravitational parameter mu = G * M
signal.planet.gravity_mu {
    : Scalar<m³/s², 1e12..1e18>
    : strata(genesis)
    : title("Gravitational Parameter")

    resolve {
        const.physics.gravitational * signal.planet.mass
    }

    assert {
        prev >= 1e12 : fatal, "Gravitational parameter below minimum"
        prev <= 1e18 : fatal, "Gravitational parameter above maximum"
    }
}

# Surface gravity g = mu / R^2
signal.planet.surface_gravity {
    : Scalar<m/s², 1..50>
    : strata(genesis)
    : title("Surface Gravity")

    resolve {
        signal.planet.gravity_mu / (signal.planet.radius * signal.planet.radius)
    }

    assert {
        prev >= 1.0 : warn, "Surface gravity unusually low"
        prev <= 50.0 : warn, "Surface gravity unusually high"
    }
}

# =============================================================================
# Thermal Signals
# =============================================================================

signal.core.temp {
    : Scalar<K, 100..10000>
    : strata(thermal)
    : title("Core Temperature")
    : symbol("T_core")

    # Signal-local config - showcasing the new feature
    # These values become accessible as config.core.temp.<key>
    config {
        decay_halflife: 4.5e17 <s>
    }

    resolve {
        # Using dt-robust decay operator instead of manual exp(-ln2*dt/halflife)
        # Note: using signal-local config via config.core.temp.decay_halflife
        decay(prev, config.core.temp.decay_halflife) + sum(inputs)
    }

    assert {
        prev >= 100 <K>
        prev <= 10000 <K>
        prev > 0 : fatal, "Core temperature must be positive"
    }
}

signal.mantle.temp {
    : Scalar<K, 500..5000>
    : strata(thermal)
    : title("Mantle Temperature")

    # Signal-local config for mantle thermal properties
    config {
        core_coupling_factor: 0.01
        min_temp: 500.0
        max_temp: 5000.0
    }

    resolve {
        # Mantle cools as heat flows to surface, coupled to core
        let core_coupling = (signal.core.temp - prev) * config.mantle.temp.core_coupling_factor
        clamp(prev + core_coupling + sum(inputs), config.mantle.temp.min_temp, config.mantle.temp.max_temp)
    }

    assert {
        prev >= config.mantle.temp.min_temp : warn, "Mantle temperature below minimum"
        prev <= config.mantle.temp.max_temp : warn, "Mantle temperature above maximum"
    }
}

signal.surface.temp {
    : Scalar<K, 50..500>
    : strata(thermal)
    : title("Surface Temperature")

    # Signal-local const for geothermal contribution
    const {
        geothermal_contribution: 0.875
    }

    resolve {
        # geothermal = gradient * 0.001 * initial_thickness / 1000
        # = 25 * 0.001 * 35000 / 1000 = 0.875 K
        const.thermal.surface_temp + const.surface.temp.geothermal_contribution + sum(inputs)
    }

    assert {
        prev >= 50.0 : warn, "Surface temperature below habitable range"
        prev <= 500.0 : warn, "Surface temperature above habitable range"
    }
}

# Surface heat flow - showcasing W/m² Unicode superscript
signal.surface.heat_flow {
    : Scalar<W/m², 0.01..0.5>
    : strata(thermal)
    : title("Surface Heat Flow")
    : symbol("q")

    config {
        baseline: 0.065
        conductivity: 2.5
    }

    resolve {
        # Heat flow = conductivity * (mantle_temp - surface_temp) / thickness
        # Simplified: baseline + thermal contribution from mantle
        let thermal_contribution = (signal.mantle.temp - signal.surface.temp) * 0.00001
        clamp(config.surface.heat_flow.baseline + thermal_contribution + sum(inputs), 0.01, 0.5)
    }

    assert {
        prev >= 0.01 : warn, "Heat flow below realistic minimum"
        prev <= 0.5 : warn, "Heat flow above realistic maximum"
    }
}

# =============================================================================
# Crust Signals - Isostasy Implementation
# =============================================================================

# Crustal density - showcasing kg/m³ Unicode superscript
signal.crust.density {
    : Scalar<kg/m³, 2000..3500>
    : strata(tectonics)
    : title("Crustal Density")
    : symbol("ρ_crust")

    config {
        continental: 2700.0
        oceanic: 2900.0
        min: 2000.0
        max: 3500.0
    }

    resolve {
        # Default to continental density, can be modified by inputs
        clamp(prev + sum(inputs), config.crust.density.min, config.crust.density.max)
    }

    assert {
        prev >= config.crust.density.min : warn, "Crustal density below minimum"
        prev <= config.crust.density.max : warn, "Crustal density above maximum"
    }
}

# Crustal thickness signal
signal.crust.thickness {
    : Scalar<m, 3000..80000>
    : strata(tectonics)
    : title("Crustal Thickness")
    : symbol("h_crust")

    # Signal-local config for thickness constraints
    config {
        min: 3000.0
        max: 80000.0
    }

    resolve {
        clamp(prev + sum(inputs), config.crust.thickness.min, config.crust.thickness.max)
    }

    assert {
        prev >= config.crust.thickness.min : warn, "Crust thinning below minimum"
        prev <= config.crust.thickness.max : warn, "Crust thickening above maximum"
    }
}

signal.crust.total_thickness {
    : Scalar<m, 0..100000>
    : strata(tectonics)
    : title("Total Crustal Thickness")

    resolve {
        signal.crust.thickness
    }

    assert {
        prev >= 0.0 : warn, "Total thickness cannot be negative"
        prev <= 100000.0 : warn, "Total thickness exceeds maximum"
    }
}

# Isostatic factor: 1 - (crust_density / mantle_density)
# For Earth: (1 - 2700/3300) = 0.182
signal.isostasy.factor {
    : Scalar<1, 0..1>
    : strata(tectonics)
    : title("Isostatic Factor")

    # Signal-local config for density values used in isostasy calculation
    config {
        crustal_density: 2700.0
        mantle_density: 3300.0
    }

    resolve {
        # Using user-defined function for density contrast calculation
        isostasy.buoyancy_factor(config.isostasy.factor.crustal_density, config.isostasy.factor.mantle_density)
    }

    assert {
        prev >= 0.0 : warn, "Isostatic factor cannot be negative"
        prev <= 1.0 : warn, "Isostatic factor cannot exceed 1"
    }
}

# Reference level = factor * reference_thickness = 0.182 * 35000 = 6370 m
signal.isostasy.reference_level {
    : Scalar<m, 0..10000>
    : strata(tectonics)
    : title("Isostatic Reference Level")

    resolve {
        signal.isostasy.factor * const.isostasy.reference_thickness
    }

    assert {
        prev >= 0.0 : warn, "Reference level cannot be negative"
        prev <= 10000.0 : warn, "Reference level exceeds maximum"
    }
}

# Isostatic elevation = factor * thickness - reference_level
signal.isostasy.elevation {
    : Scalar<m, -15000..15000>
    : strata(tectonics)
    : title("Isostatic Elevation")

    resolve {
        # Using user-defined function for isostatic elevation
        isostasy.compute_elevation(signal.crust.thickness, signal.isostasy.factor, signal.isostasy.reference_level)
    }

    assert {
        prev >= -15000.0 : warn, "Isostatic elevation below minimum"
        prev <= 15000.0 : warn, "Isostatic elevation above maximum"
    }
}

# =============================================================================
# Dynamic Topography
# =============================================================================

# Offset from mantle convection, breaks perfect r=1.0 correlation
signal.topography.dynamic_offset {
    : Scalar<m, -1200..2400>
    : strata(tectonics)
    : title("Dynamic Topography Offset")

    # Signal-local config for dynamic topography parameters
    config {
        flow_coupling: 1.0
        uplift_scale: 0.01
    }

    resolve {
        let thermal_gradient = (signal.mantle.temp - const.thermal.mantle_temp) / 1000.0
        let uplift = thermal_gradient * const.topography.max_plume_uplift * config.topography.dynamic_offset.flow_coupling * config.topography.dynamic_offset.uplift_scale
        clamp(
            prev + uplift + sum(inputs),
            -const.topography.max_slab_depression,
            const.topography.max_plume_uplift
        )
    }

    assert {
        prev >= -const.topography.max_slab_depression : warn, "Dynamic offset below slab depression limit"
        prev <= const.topography.max_plume_uplift : warn, "Dynamic offset above plume uplift limit"
    }
}

# =============================================================================
# Combined Elevation (Isostasy + Dynamic)
# =============================================================================

signal.crust.elevation {
    : Scalar<m, -11000..9000>
    : strata(tectonics)
    : title("Surface Elevation")
    : symbol("h_elev")

    # Signal-local config for elevation bounds (Earth-realistic limits)
    config {
        max_depth: 11000.0
        max_height: 9000.0
    }

    resolve {
        # Combined isostatic + dynamic elevation
        clamp(
            signal.isostasy.elevation + signal.topography.dynamic_offset + sum(inputs),
            -config.crust.elevation.max_depth,
            config.crust.elevation.max_height
        )
    }

    assert {
        prev >= -config.crust.elevation.max_depth : warn, "Elevation below maximum ocean depth"
        prev <= config.crust.elevation.max_height : warn, "Elevation above maximum mountain height"
    }
}

# =============================================================================
# Derived Crust Properties
# =============================================================================

# Lithostatic pressure at base: P = P_surface + rho * g * depth
signal.crust.pressure_base {
    : Scalar<kg/m/s², 1e5..3e9>
    : strata(tectonics)
    : title("Base Crustal Pressure")

    # Signal-local config for pressure calculation
    config {
        surface_pressure: 100000.0
        density: 2700.0
        min: 1e5
        max: 3e9
    }

    resolve {
        # Using user-defined function for lithostatic pressure
        pressure.lithostatic(config.crust.pressure_base.surface_pressure, config.crust.pressure_base.density, signal.planet.surface_gravity, signal.crust.thickness)
    }

    assert {
        prev >= config.crust.pressure_base.min : warn, "Base pressure below minimum"
        prev <= config.crust.pressure_base.max : warn, "Base pressure above maximum"
    }
}

# Geothermal temperature at crust base
signal.crust.temp_base {
    : Scalar<K, 300..1500>
    : strata(thermal)
    : title("Base Crustal Temperature")

    resolve {
        # Using user-defined function for geothermal temperature
        # depth_km = thickness / 1000
        thermal.geothermal_temp(const.thermal.surface_temp, const.thermal.gradient, signal.crust.thickness / 1000.0)
    }

    assert {
        prev >= 300.0 : warn, "Base temperature below minimum"
        prev <= 1500.0 : warn, "Base temperature above maximum"
    }
}

# Moho depth
signal.crust.moho_depth {
    : Scalar<m, 3000..80000>
    : strata(tectonics)
    : title("Moho Depth")

    resolve {
        signal.crust.thickness
    }

    assert {
        prev >= 3000.0 : warn, "Moho depth below minimum crustal thickness"
        prev <= 80000.0 : warn, "Moho depth above maximum crustal thickness"
    }
}

# =============================================================================
# Plate Boundary Stress
# =============================================================================

signal.tectonics.boundary_stress {
    : Scalar<N/m², 0..1e9>
    : strata(tectonics)
    : title("Plate Boundary Stress")

    # Signal-local config for stress calculation factors
    config {
        thermal_factor: 0.001
        thermal_scale: 1e4
        thickness_factor: 0.001
        thickness_scale: 1e3
        max_stress: 1e9
        reference_mantle_temp: 1600.0
    }

    resolve {
        let thermal_stress = abs(signal.mantle.temp - config.tectonics.boundary_stress.reference_mantle_temp) * config.tectonics.boundary_stress.thermal_scale * config.tectonics.boundary_stress.thermal_factor
        let thickness_stress = abs(signal.crust.thickness - const.isostasy.reference_thickness) * config.tectonics.boundary_stress.thickness_scale * config.tectonics.boundary_stress.thickness_factor
        clamp(prev + thermal_stress + thickness_stress + sum(inputs), 0.0, config.tectonics.boundary_stress.max_stress)
    }

    assert {
        prev >= 0.0 : warn, "Boundary stress cannot be negative"
        prev <= config.tectonics.boundary_stress.max_stress : warn, "Boundary stress exceeds maximum"
    }
}

# =============================================================================
# Fractures (Tectonic Events)
# =============================================================================

# Rifting: thin crust + high stress -> rift opening
fracture.tectonics.rift {
    when {
        signal.crust.thickness < 25000
        signal.tectonics.boundary_stress > 5e8
    }

    emit {
        signal.tectonics.boundary_stress <- -signal.tectonics.boundary_stress * 0.8
        signal.crust.thickness <- -500.0
        signal.topography.dynamic_offset <- 200.0
    }
}

# Orogeny: thick crust + compression -> mountain building
fracture.tectonics.orogeny {
    when {
        signal.crust.thickness > 50000
        signal.tectonics.boundary_stress > 7e8
    }

    emit {
        signal.tectonics.boundary_stress <- -signal.tectonics.boundary_stress * 0.6
        signal.crust.thickness <- 1000.0
        signal.topography.dynamic_offset <- -100.0
    }
}

# Volcanism: hot mantle + thin crust -> volcanic activity
fracture.thermal.volcanism {
    when {
        signal.mantle.temp > 1800 <K>
        signal.crust.thickness < 30000
    }

    emit {
        signal.mantle.temp <- -50.0
        signal.crust.thickness <- 100.0
        signal.topography.dynamic_offset <- 50.0
    }
}

# Radioactive heating burst
fracture.core.decay_heat {
    when {
        signal.core.temp < 5000 <K>
    }

    emit {
        signal.core.temp <- 10.0
    }
}

# =============================================================================
# Fields (Observer Data)
# =============================================================================

field.elevation.map {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Elevation Map")

    measure {
        signal.crust.elevation
    }
}

field.thickness.map {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Thickness Map")

    measure {
        signal.crust.thickness
    }
}

field.thermal.core {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Core Temperature Field")

    measure {
        signal.core.temp
    }
}

field.thermal.mantle {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Mantle Temperature Field")

    measure {
        signal.mantle.temp
    }
}

field.pressure.crustal {
    : Scalar<kg/m/s²>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Pressure Field")

    measure {
        signal.crust.pressure_base
    }
}

field.stress.boundary {
    : Scalar<N/m²>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Boundary Stress Field")

    measure {
        signal.tectonics.boundary_stress
    }
}

field.topography.dynamic {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Dynamic Topography Field")

    measure {
        signal.topography.dynamic_offset
    }
}

field.isostasy.elevation_field {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Isostatic Elevation Field")

    measure {
        signal.isostasy.elevation
    }
}

# Density field - showcasing kg/m³ Unicode superscript
field.density.crustal {
    : Scalar<kg/m³>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Density Field")

    measure {
        signal.crust.density
    }
}

# Heat flow field - showcasing W/m² Unicode superscript
field.thermal.heat_flow {
    : Scalar<W/m²>
    : strata(thermal)
    : topology(point_cloud)
    : title("Surface Heat Flow Field")

    measure {
        signal.surface.heat_flow
    }
}
