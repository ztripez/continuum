# Terra Hydrology Module
# Water cycle: precipitation, evaporation, runoff, and sediment transport
#
# This module handles the hydrological cycle and surface water dynamics.
# Depends on atmosphere for temperature and precipitation drivers.
# =============================================================================

# =============================================================================
# Hydrology Constants
# =============================================================================

const {
    # Water phase boundaries (K at 1 atm)
    hydrology.freezing_point_k: 273.15
    hydrology.boiling_point_k: 373.15

    # Latent heats (J/kg)
    hydrology.latent_heat_vaporization: 2.45e6
    hydrology.latent_heat_sublimation: 2.83e6
    hydrology.latent_heat_fusion: 3.34e5

    # Physical constants
    hydrology.psychrometric_constant: 0.066     # kPa/K
    hydrology.priestley_taylor_alpha: 1.26      # PT coefficient

    # Sediment
    hydrology.max_sediment_load: 10.0           # Maximum sediment capacity

    # Reference values
    hydrology.reference_water_mass_kg: 1e8      # kg per cell for "saturated"
}

# =============================================================================
# Hydrology Configuration
# =============================================================================

config {
    # Cell configuration
    hydrology.cell_count: 1000                  # Number of surface water cells

    # Evaporation
    hydrology.evaporation_coefficient: 1.0
    hydrology.bulk_transfer_coefficient: 1.5e-3
    hydrology.wind_speed_m_s: 5.0

    # Precipitation
    hydrology.base_precipitation_rate: 1e-5     # kg/m²/s base rate
    hydrology.orographic_factor: 2.0            # Enhancement on windward slopes
    hydrology.rain_shadow_factor: 0.3           # Reduction on leeward slopes

    # Runoff
    hydrology.runoff_coefficient: 0.3
    hydrology.infiltration_rate: 1e-6           # m/s

    # Sediment transport
    hydrology.erosion_rate: 1e-6                # m/s base erosion
    hydrology.deposition_rate: 1e-7             # m/s base deposition
    hydrology.sediment_capacity_factor: 1.0

    # Ice/glacier
    hydrology.ice_flow_rate: 1e-10              # m/s base glacial flow
    hydrology.sublimation_rate: 1e-8            # kg/m²/s sublimation rate

    # Initial values
    hydrology.initial_water_mass: 1e6
    hydrology.initial_ice_mass: 0.0
    hydrology.initial_sediment_load: 0.2
    hydrology.initial_runoff_accumulation: 0.0
    hydrology.initial_evaporation_rate: 1e-6
    hydrology.initial_precipitation_rate: 1e-5
}

# =============================================================================
# Hydrology Functions
# =============================================================================

# Determine water phase from temperature
fn hydrology.water_phase(temperature_k) {
    if temperature_k < 273.15 {
        0.0  # Ice
    } else {
        if temperature_k < 373.15 {
            1.0  # Liquid
        } else {
            2.0  # Vapor
        }
    }
}

# Saturation vapor pressure (simplified)
fn hydrology.saturation_vapor_pressure(temperature_k) {
    let t_celsius = temperature_k - 273.15 in
    610.94 * maths.exp((17.625 * t_celsius) / (t_celsius + 243.04))
}

# Water presence from mass (normalized 0-1)
fn hydrology.water_presence(water_mass_kg, reference_mass_kg) {
    : uses(maths.clamping)
    
    maths.clamp(water_mass_kg / reference_mass_kg, 0.0, 1.0)
}

# =============================================================================
# Surface Water Signals
# =============================================================================

# Global water mass budget
signal hydrology.water_mass {
    : Scalar<kg, 0..1e20>
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Total Surface Water Mass")
    : symbol("M_water")

    config {
        initial: 1e18
        min: 0.0
        max: 1e20
    }

    resolve {
        # Water budget: precipitation - evaporation + external inputs
        # Net rate = (precip - evap) * surface_area
        let net_rate = (hydrology.precipitation_rate - hydrology.evaporation_rate) * 5.1e14 in
        maths.clamp(dt.integrate(prev, net_rate) + inputs, config.hydrology.water_mass.min, config.hydrology.water_mass.max)
    }

    assert {
        prev >= 0.0 : warn, "Water mass cannot be negative"
    }
}

# Ice mass (glaciers, ice sheets)
signal hydrology.ice_mass {
    : Scalar<kg, 0..1e19>
    : stratum(hydrology)
    : title("Total Ice Mass")
    : symbol("M_ice")

    config {
        initial: 2.6e19  # Earth's ice mass ~26 million km³
        sublimation_rate: 1e-8
    }

    resolve {
        # Ice mass changes through freezing/melting and sublimation
        let temp = surface.temp in
        let phase = hydrology.water_phase(temp) in

        if phase < 0.5 {
            # Freezing conditions - ice can accumulate
            prev + inputs
        } else {
            # Melting/sublimation conditions - sublimation rate * area
            let sublimation_rate = config.hydrology.ice_mass.sublimation_rate * 1e13 in
            maths.max(dt.integrate(prev, -sublimation_rate) + inputs, 0.0)
        }
    }

    assert {
        prev >= 0.0 : warn, "Ice mass cannot be negative"
    }
}

# =============================================================================
# Evaporation
# =============================================================================

signal hydrology.evaporation_rate {
    : Scalar<kg/m²/s, 0..1e-3>
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Evaporation Rate")
    : symbol("E")

    config {
        bulk_transfer: 1.5e-3
        wind_speed: 5.0
        min: 0.0
        max: 1e-3
    }

    resolve {
        # Bulk aerodynamic formula: E = C_E * U * (q_sat - q_air)
        let temp = surface.temp in
        let phase = hydrology.water_phase(temp) in

        if phase > 0.5 and phase < 1.5 {
            # Liquid water - normal evaporation
            let e_sat = hydrology.saturation_vapor_pressure(temp) in
            let q_sat = 0.622 * e_sat / 101325.0 in  # Mixing ratio at saturation
            let q_air = q_sat * 0.6 in                # Assume 60% RH
            let evap = config.hydrology.evaporation_rate.bulk_transfer * config.hydrology.evaporation_rate.wind_speed * (q_sat - q_air) * 1.2 in
            maths.clamp(evap + inputs, config.hydrology.evaporation_rate.min, config.hydrology.evaporation_rate.max)
        } else {
            # Ice or vapor - reduced/no evaporation
            inputs
        }
    }

    assert {
        prev >= 0.0 : warn, "Evaporation rate cannot be negative"
    }
}

# =============================================================================
# Precipitation
# =============================================================================

signal hydrology.precipitation_rate {
    : Scalar<kg/m²/s, 0..1e-2>
    : initial(0.0)
    : initial(0.0)
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Precipitation Rate")
    : symbol("P")

    config {
        base_rate: 1e-5
        water_vapor_sensitivity: 1e-6
        min: 0.0
        max: 1e-2
    }

    resolve {
        # Precipitation depends on water vapor availability
        let water_vapor = atmosphere.water_vapor in
        let precip = config.hydrology.precipitation_rate.base_rate + water_vapor * config.hydrology.precipitation_rate.water_vapor_sensitivity in
        maths.clamp(precip + inputs, config.hydrology.precipitation_rate.min, config.hydrology.precipitation_rate.max)
    }

    assert {
        prev >= 0.0 : warn, "Precipitation rate cannot be negative"
    }
}

# =============================================================================
# Runoff and Flow
# =============================================================================

signal hydrology.runoff_accumulation {
    : Scalar<kg/s, 0..1e15>
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Runoff Accumulation")
    : symbol("Q")

    config {
        coefficient: 0.3
        min: 0.0
        max: 1e15
    }

    resolve {
        # Runoff = precipitation * runoff_coefficient * area
        let precip = hydrology.precipitation_rate in
        let evap = hydrology.evaporation_rate in
        let net_water = maths.max(precip - evap, 0.0) in
        let runoff = net_water * config.hydrology.runoff_accumulation.coefficient * 5.1e14 <m²> in

        maths.clamp(runoff + inputs, config.hydrology.runoff_accumulation.min, config.hydrology.runoff_accumulation.max)
    }

    assert {
        prev >= 0.0 : warn, "Runoff cannot be negative"
    }
}

# =============================================================================
# Sediment Transport
# =============================================================================

signal hydrology.sediment_load {
    : Scalar<kg/m², 0..10>
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Sediment Load")
    : symbol("S")

    config {
        erosion_rate: 1e-6
        deposition_rate: 1e-7
        max_load: 10.0
    }

    resolve {
        # Sediment transport depends on runoff and slope
        let runoff = hydrology.runoff_accumulation in
        let erosion_rate = runoff * config.hydrology.sediment_load.erosion_rate / 1e12 in
        let deposition_rate = prev * config.hydrology.sediment_load.deposition_rate in
        let net_rate = erosion_rate - deposition_rate in

        maths.clamp(dt.integrate(prev, net_rate) + inputs, 0.0, config.hydrology.sediment_load.max_load)
    }

    assert {
        prev >= 0.0 : warn, "Sediment load cannot be negative"
        prev <= const.hydrology.max_sediment_load : warn, "Sediment load exceeds maximum"
    }
}

# =============================================================================
# Weathering (Chemical erosion)
# =============================================================================

signal hydrology.chemical_weathering {
    : Scalar<kg/m²/yr, 0..1>
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Chemical Weathering Rate")
    : symbol("W_chem")

    config {
        base_rate: 0.01
        temperature_sensitivity: 0.05 <K⁻¹>
        runoff_sensitivity: 1e-16
        co2_sensitivity: 0.001
    }

    resolve {
        # Weathering increases with temperature, runoff, and CO2
        let temp = surface.temp in
        let runoff = hydrology.runoff_accumulation in
        let co2 = atmosphere.co2_ppmv in

        let temp_factor = maths.exp(config.hydrology.chemical_weathering.temperature_sensitivity * (temp - 288.0)) in
        let runoff_factor = 1.0 + runoff * config.hydrology.chemical_weathering.runoff_sensitivity in
        let co2_factor = 1.0 + (co2 - 280.0) * config.hydrology.chemical_weathering.co2_sensitivity in

        maths.clamp(config.hydrology.chemical_weathering.base_rate * temp_factor * runoff_factor * co2_factor + inputs, 0.0, 1.0)
    }

    assert {
        prev >= 0.0 : warn, "Weathering rate cannot be negative"
    }
}

# =============================================================================
# Water Temperature
# =============================================================================

signal hydrology.water_temperature {
    : Scalar<K, 271..313>
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Surface Water Temperature")
    : symbol("T_w")

    config {
        relaxation_tau_s: 3.1536e7       # ~1 year relaxation time
        latitude_adjustment: 10.0         # K difference pole to equator
        min_temp_k: 271.0                 # Just above freezing
        max_temp_k: 313.0                 # ~40°C ocean surface max
    }

    resolve {
        # Water temperature relaxes toward surface temperature with latitude adjustment
        let surface_temp = surface.temp in
        let target_temp = maths.clamp(surface_temp, config.hydrology.water_temperature.min_temp_k, config.hydrology.water_temperature.max_temp_k) in
        dt.relax_to(prev, target_temp, config.hydrology.water_temperature.relaxation_tau_s) + inputs
    }

    assert {
        prev >= config.hydrology.water_temperature.min_temp_k : warn, "Water temperature too low"
        prev <= config.hydrology.water_temperature.max_temp_k : warn, "Water temperature too high"
    }
}

# =============================================================================
# Groundwater System
# =============================================================================

# Groundwater saturation fraction
signal hydrology.groundwater_saturation {
    : Scalar<1, 0..1>
    : initial(0.5)
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Groundwater Saturation")
    : symbol("S_gw")

    config {
        initial: 0.5
        porosity: 0.3                     # Typical soil porosity
        max_capacity_kg_m2: 1e5           # Maximum water per unit area
    }

    resolve {
        # Saturation changes from infiltration (increase) and baseflow (decrease)
        let infiltration = hydrology.infiltration_rate in
        let baseflow = hydrology.baseflow_rate in
        let net_rate = (infiltration - baseflow) / config.hydrology.groundwater_saturation.max_capacity_kg_m2 in
        maths.clamp(dt.integrate(prev, net_rate) + inputs, 0.0, 1.0)
    }

    assert {
        prev >= 0.0 : warn, "Groundwater saturation cannot be negative"
        prev <= 1.0 : warn, "Groundwater saturation cannot exceed 1"
    }
}

# Infiltration rate from surface to groundwater
signal hydrology.infiltration_rate {
    : Scalar<kg/m²/s, 0..1e-2>
    : uses(maths.clamping)
    : stratum(atmosphere)
    : initial(0.0)
    : title("Infiltration Rate")
    : symbol("I")

    config {
        permeability_m_per_s: 1e-6        # Mixed regolith/soil
        min_surface_water_kg: 1000.0      # Minimum surface water to infiltrate
        max_rate: 2.8e-3                  # Max ~10 mm/hour
        water_density: 1000.0             # kg/m³
        relaxation_time: 3600.0           # 1 hour relaxation to equilibrium
    }

    resolve {
        # NOTE: To avoid cycle with groundwater_saturation, this signal relaxes
        # toward an equilibrium rate rather than computing instantaneously.
        # The equilibrium depends on saturation, but relaxation uses prev,
        # which breaks the instantaneous dependency.
        # 
        # Equilibrium rate = permeability * available_pore * density
        # We approximate by relaxing toward a reasonable rate based on typical saturation
        let base_rate = config.hydrology.infiltration_rate.permeability_m_per_s 
                      * 0.15  # ~50% saturation leaves 15% pore space (0.3 * 0.5)
                      * config.hydrology.infiltration_rate.water_density in
        let target = base_rate + inputs in
        maths.clamp(
            dt.relax_to(prev, target, config.hydrology.infiltration_rate.relaxation_time),
            0.0, 
            config.hydrology.infiltration_rate.max_rate
        )
    }

    assert {
        prev >= 0.0 : warn, "Infiltration rate cannot be negative"
    }
}

# Baseflow rate from groundwater to surface streams
signal hydrology.baseflow_rate {
    : Scalar<kg/m²/s, 0..1e-3>
    : uses(maths.clamping)
    : stratum(atmosphere)
    : initial(0.0)
    : title("Baseflow Rate")
    : symbol("Q_base")

    config {
        threshold: 0.7                    # Saturation threshold for baseflow
        coefficient: 1e-6                 # Discharge coefficient (1/s)
        max_rate: 1e-3
        relaxation_time: 3600.0           # 1 hour relaxation to equilibrium
    }

    resolve {
        # NOTE: To avoid cycle with groundwater_saturation, this signal relaxes
        # toward an equilibrium rate rather than computing instantaneously.
        # The equilibrium depends on saturation, but relaxation uses prev,
        # which breaks the instantaneous dependency.
        #
        # Equilibrium: baseflow increases when saturation > threshold
        # Approximate with typical excess saturation (0.1 above threshold)
        let base_rate = 0.1 * config.hydrology.baseflow_rate.coefficient * 1e5 in
        let target = base_rate + inputs in
        maths.clamp(
            dt.relax_to(prev, target, config.hydrology.baseflow_rate.relaxation_time),
            0.0,
            config.hydrology.baseflow_rate.max_rate
        )
    }

    assert {
        prev >= 0.0 : warn, "Baseflow rate cannot be negative"
    }
}

# =============================================================================
# Dissolved Content
# =============================================================================

# Dissolved gas in surface water
signal hydrology.dissolved_gas {
    : Scalar<mol/m³, 0..100>
    : stratum(hydrology)
    : title("Dissolved Gas Content")
    : symbol("G")

    config {
        initial: 10.0                     # mol/m³ proxy
        exchange_rate: 1e-7               # Gas exchange rate with atmosphere
        temperature_sensitivity: -0.02 <K⁻¹>  # Solubility decreases with temperature
    }

    resolve {
        # Dissolved gas depends on temperature and atmospheric exchange
        let temp = hydrology.water_temperature in
        let temp_factor = maths.exp(config.hydrology.dissolved_gas.temperature_sensitivity * (temp - 288.0)) in
        let equilibrium = config.hydrology.dissolved_gas.initial * temp_factor in
        dt.relax_to(prev, equilibrium, 3.1536e7) + inputs
    }

    assert {
        prev >= 0.0 : warn, "Dissolved gas cannot be negative"
    }
}

# =============================================================================
# Flow Topology
# =============================================================================

# Flow accumulation (upstream contributing area proxy)
signal hydrology.flow_accumulation {
    : Scalar<1, 0..1e6>
    : stratum(hydrology)
    : title("Flow Accumulation")
    : symbol("A_flow")

    config {
        base_value: 1.0
        runoff_sensitivity: 1e-14
    }

    resolve {
        # Flow accumulation scales with runoff
        let runoff = hydrology.runoff_accumulation in
        config.hydrology.flow_accumulation.base_value + runoff * config.hydrology.flow_accumulation.runoff_sensitivity + inputs
    }

    assert {
        prev >= 0.0 : warn, "Flow accumulation cannot be negative"
    }
}

# Stream order (Strahler)
signal hydrology.stream_order {
    : Scalar<1, 0..10>
    : initial(0.0)
    : uses(maths.clamping)
    : stratum(hydrology)
    : title("Stream Order")
    : symbol("ω")

    config {
        flow_threshold: 100.0             # Flow accumulation for stream initiation
    }

    resolve {
        # Simplified stream order from flow accumulation
        let flow_acc = hydrology.flow_accumulation in
        if flow_acc < config.hydrology.stream_order.flow_threshold {
            0.0  # Hillslope
        } else {
            maths.clamp(maths.log10(flow_acc / config.hydrology.stream_order.flow_threshold) + 1.0, 0.0, 10.0)
        }
    }

    assert {
        prev >= 0.0 : warn, "Stream order cannot be negative"
        prev <= 10.0 : warn, "Stream order exceeds maximum"
    }
}

# =============================================================================
# Hydrology Fractures
# =============================================================================

# Flash flood: sudden high precipitation
fracture hydrology.flash_flood {
    : stratum(hydrology)

    when {
        hydrology.precipitation_rate > 5e-4
        hydrology.runoff_accumulation > 1e14
    }

    collect {
        hydrology.sediment_load <- 1.0
        hydrology.runoff_accumulation <- -hydrology.runoff_accumulation * 0.5
    }
}

# Drought: prolonged low precipitation
fracture hydrology.drought {
    : stratum(hydrology)

    when {
        hydrology.precipitation_rate < 1e-6
        hydrology.water_mass < 1e17
    }

    collect {
        hydrology.evaporation_rate <- -hydrology.evaporation_rate * 0.5
    }
}

# Glacial surge
fracture hydrology.glacial_surge {
    : stratum(hydrology)

    when {
        hydrology.ice_mass > 3e19
        surface.temp < 270.0 <K>
    }

    collect {
        hydrology.ice_mass <- -1e18
        hydrology.sediment_load <- 2.0
    }
}

# -----------------------------------------------------------------------------
# Process-Based Hydrology Fractures
# -----------------------------------------------------------------------------

# Precipitation coupling: atmosphere → hydrology
# Equilibrium-based water redistribution with orographic forcing
# 
# Physics:
# - Windward slopes receive enhanced precipitation (orographic lift)
# - Leeward slopes receive reduced precipitation (rain shadow)
# - Water relaxes toward equilibrium distribution over geological timescales
# - Mass-conserving: total water redistributed but not created/destroyed
#
# Implementation:
# - Computes orographic weights based on prevailing wind and elevation gradients
# - Target equilibrium is proportional to orographic weight
# - Relaxation preserves total water mass
fracture hydrology.precipitation_coupling {
    : stratum(hydrology)

    config {
        # Water cycle timescale (~1000 years for atmospheric redistribution)
        water_cycle_timescale_s: 3.1536e10  # 1000 years
        
        # Orographic precipitation parameters
        orographic_enhancement: 2.0          # Windward slope precipitation multiplier
        rain_shadow_factor: 0.3              # Leeward slope precipitation reduction
        hadley_cell_boundary_deg: 30.0       # Subtropical high boundary (latitude)
        
        # Base precipitation rate (kg/m²/s) for normalization
        base_precipitation_rate: 1e-5
        # Base evaporation rate (kg/m²/s) for mass balance
        base_evaporation_rate: 1e-5
        
        # Minimum water mass to trigger redistribution
        min_water_mass_kg: 1e10
    }

    when {
        hydrology.water_mass > config.hydrology.precipitation_coupling.min_water_mass_kg
    }

    collect {
        # Equilibrium-based water redistribution
        # At dt >> timescale: approaches equilibrium
        # At dt << timescale: small changes
        
        let total_water = hydrology.water_mass
        
        # Compute relaxation factor: 1 - exp(-dt/tau)
        # For dt ~Myr, tau ~1000yr: relaxation_factor ≈ 1 (near equilibrium)
        let relaxation_factor = 0.01  # Simplified for CDSL (needs dt context)
        
        # Orographic weight (simplified - would need spatial neighbors in full model)
        # For now, use latitude-based approximation
        # Tropical regions (low latitude) get more precipitation
        let orographic_weight = 1.0  # Placeholder - needs spatial context
        
        # Equilibrium water = total * (weight / sum_weights)
        # Simplified: move toward mean with small adjustment
        let equilibrium = total_water
        let current_mass = hydrology.water_mass
        
        # Relaxation delta toward equilibrium (mass-conserving)
        let delta = (equilibrium - current_mass) * relaxation_factor
        hydrology.water_mass <- delta
        
        # Emit precipitation rate for observation (not net change)
        # Normalized so global mean = base rate
        let precip_rate = config.hydrology.precipitation_coupling.base_precipitation_rate * orographic_weight
        hydrology.precipitation_rate <- precip_rate
    }
}

# Hydraulic erosion: stream power erosion model
# E = K * A^m * S^n (stream power law)
fracture hydrology.hydraulic_erosion {
    : stratum(hydrology)

    config {
        erodibility: 1e-6                   # K coefficient (m/Myr)
        m_exponent: 0.5                     # Area exponent (typically 0.4-0.6)
        n_exponent: 1.0                     # Slope exponent (typically 1.0)
        erosion_threshold: 100.0            # Min flow accumulation for erosion
        max_erosion_rate_m_per_myr: 1000.0  # Cap erosion rate
        sediment_conversion: 1.0            # Eroded material → sediment
    }

    when {
        hydrology.flow_accumulation > config.hydrology.hydraulic_erosion.erosion_threshold
        hydrology.runoff_accumulation > 1e10
    }

    collect {
        # Stream power erosion: E = K * A^m * S^n
        let flow_acc = hydrology.flow_accumulation
        let erosion_factor = config.hydrology.hydraulic_erosion.erodibility * maths.pow(flow_acc, config.hydrology.hydraulic_erosion.m_exponent)
        let erosion_rate = maths.min(erosion_factor, config.hydrology.hydraulic_erosion.max_erosion_rate_m_per_myr)

        # Eroded material becomes sediment
        hydrology.sediment_load <- erosion_rate * config.hydrology.hydraulic_erosion.sediment_conversion * 1e-6
    }
}

# Sediment transport: routes sediment downstream along drainage network
# When transport capacity exceeded, sediment deposits
fracture hydrology.sediment_transport {
    : stratum(hydrology)

    config {
        capacity_coefficient: 1e-4          # Transport capacity coefficient
        discharge_exponent: 0.6             # Discharge influence (3/5 = 0.6, stream power law)
        deposition_rate: 0.1                # Fraction of excess deposited per timestep
    }

    when {
        hydrology.sediment_load > 0.1
        hydrology.runoff_accumulation > 1e8
    }

    collect {
        # Transport capacity: C = K * Q^(3/5) (stream power law)
        # Physics: sediment transport capacity proportional to discharge
        # Use normalized discharge (dimensionless) to compute capacity
        let discharge = hydrology.runoff_accumulation
        let discharge_normalized = discharge / 1e14
        let capacity = config.hydrology.sediment_transport.capacity_coefficient * maths.pow(discharge_normalized, 3/5)
        let sediment = hydrology.sediment_load

        # If sediment exceeds capacity, deposit excess
        let excess = maths.max(sediment - capacity, 0.0)
        let deposition = excess * config.hydrology.sediment_transport.deposition_rate
        hydrology.sediment_load <- -deposition
    }
}

# Water thermal relaxation: couples water temperature to climate
# Water temperature relaxes toward surface temperature with latitude adjustment
fracture hydrology.water_thermal_relaxation {
    : stratum(hydrology)
    : uses(maths.clamping)

    config {
        relaxation_timescale_s: 3.1536e7    # ~1 year relaxation
        pole_to_equator_gradient_k: 30.0    # Temperature gradient
        min_water_temp_k: 271.0             # Just above freezing
        max_water_temp_k: 313.0             # ~40C ocean surface max
    }

    when {
        hydrology.water_mass > 1e10
    }

    collect {
        # Water temperature relaxes toward climate-adjusted equilibrium
        let surface_temp = surface.temp
        let target = maths.clamp(surface_temp, config.hydrology.water_thermal_relaxation.min_water_temp_k, config.hydrology.water_thermal_relaxation.max_water_temp_k)
        let current_temp = hydrology.water_temperature
        let delta = (target - current_temp) * 0.01
        hydrology.water_temperature <- delta
    }
}

# Evaporation coupling: hydrology → atmosphere
# Water evaporates from surface based on temperature and water availability
# Couples to atmosphere via water vapor emission
fracture hydrology.evaporation_coupling {
    : stratum(hydrology)

    config {
        # Bulk aerodynamic transfer coefficient
        bulk_transfer_coefficient: 1.5e-3
        # Reference wind speed (m/s)
        wind_speed_m_per_s: 5.0
        # Minimum water mass for evaporation
        min_water_mass_kg: 1e10
        # Saturation mixing ratio scaling
        mixing_ratio_scale: 0.622
        # Reference pressure (Pa)
        reference_pressure_pa: 101325.0
        # Assumed relative humidity
        relative_humidity: 0.6
    }

    when {
        hydrology.water_mass > config.hydrology.evaporation_coupling.min_water_mass_kg
        hydrology.water_temperature > 273.15 <K>
    }

    collect {
        # Bulk aerodynamic formula: E = C_E * U * (q_sat - q_air)
        # Where C_E = bulk transfer coefficient, U = wind speed
        # q_sat = saturation mixing ratio, q_air = actual mixing ratio

        let temp = hydrology.water_temperature
        let e_sat = hydrology.saturation_vapor_pressure(temp)
        
        # Saturation mixing ratio: q_sat = 0.622 * e_sat / P
        let q_sat = config.hydrology.evaporation_coupling.mixing_ratio_scale * e_sat / config.hydrology.evaporation_coupling.reference_pressure_pa
        
        # Actual mixing ratio (assume 60% relative humidity)
        let q_air = q_sat * config.hydrology.evaporation_coupling.relative_humidity
        
        # Evaporation rate (kg/m²/s) = C_E * U * (q_sat - q_air) * air_density
        # Air density ~1.2 kg/m³
        let evap_rate = config.hydrology.evaporation_coupling.bulk_transfer_coefficient 
                      * config.hydrology.evaporation_coupling.wind_speed_m_per_s 
                      * (q_sat - q_air) 
                      * 1.2
        
        # Convert to mass flux: multiply by surface area
        # Negative delta = water removed from hydrology
        let water_loss = maths.max(evap_rate * 5.1e14, 0.0)
        hydrology.water_mass <- -water_loss
        
        # Emit water vapor to atmosphere (positive = added to atmosphere)
        atmosphere.water_vapor <- water_loss * 1e-14
    }
}

# Dissolved gas exchange: temperature-dependent gas solubility
# Cold water dissolves more gas, warm water releases gas
fracture hydrology.gas_exchange {
    : stratum(hydrology)
    : uses(maths.clamping)

    config {
        solubility_cold: 0.7                # Equilibrium at cold water (~270K)
        solubility_warm: 0.3                # Equilibrium at warm water (~300K)
        cold_temp_k: 270.0
        warm_temp_k: 300.0
        exchange_timescale_s: 6.048e5       # ~7 days exchange timescale
    }

    when {
        hydrology.water_mass > 1e10
    }

    collect {
        # Gas solubility inversely related to temperature (Henry's law)
        let temp = hydrology.water_temperature
        let temp_fraction = maths.clamp((temp - config.hydrology.gas_exchange.cold_temp_k) / (config.hydrology.gas_exchange.warm_temp_k - config.hydrology.gas_exchange.cold_temp_k), 0.0, 1.0)
        let target_gas = config.hydrology.gas_exchange.solubility_cold * (1.0 - temp_fraction) + config.hydrology.gas_exchange.solubility_warm * temp_fraction
        let current_gas = hydrology.dissolved_gas
        let delta = (target_gas * 10.0 - current_gas) * 0.001
        hydrology.dissolved_gas <- delta
    }
}

# Groundwater coupling: infiltration and baseflow
# Bidirectional water transfer between surface and crust water reservoir
fracture hydrology.groundwater_coupling {
    : stratum(hydrology)

    config {
        # Infiltration parameters
        permeability_m_per_s: 1e-6          # Mixed regolith/soil permeability
        porosity: 0.3                       # Typical soil porosity
        min_surface_water_kg: 1000.0        # Min surface water for infiltration

        # Baseflow parameters
        baseflow_threshold: 0.7             # Saturation threshold for baseflow
        baseflow_coefficient: 1e-6          # Discharge coefficient (1/s)
    }

    when {
        hydrology.water_mass > config.hydrology.groundwater_coupling.min_surface_water_kg
    }

    collect {
        # Infiltration: surface -> groundwater when pore space available
        let saturation = hydrology.groundwater_saturation
        let available_pore = maths.max(1.0 - saturation, 0.0) * config.hydrology.groundwater_coupling.porosity
        let infiltration_rate = config.hydrology.groundwater_coupling.permeability_m_per_s * available_pore * 1000.0

        # Baseflow: groundwater -> surface when saturated
        let excess = maths.max(saturation - config.hydrology.groundwater_coupling.baseflow_threshold, 0.0)
        let baseflow_rate = excess * config.hydrology.groundwater_coupling.baseflow_coefficient * 1e5

        # Net exchange
        let net_surface = baseflow_rate - infiltration_rate
        hydrology.groundwater_saturation <- -net_surface * 1e-5
    }
}

# Sediment lithification: converts thick sediment to crustal rock
# Prevents sediment saturation, creates sedimentary basins
fracture hydrology.sediment_lithification {
    : stratum(hydrology)

    config {
        threshold: 6.0                      # Sediment threshold for lithification
        rate_per_myr: 0.15                  # 15% of excess lithifies per Myr
        sediment_to_rock_m: 500.0           # 1 sediment unit -> 500m rock
        max_elevation_m: -500.0             # Only in basins (below sea level)
    }

    when {
        hydrology.sediment_load > config.hydrology.sediment_lithification.threshold
    }

    collect {
        # Excess sediment above threshold compacts and lithifies
        let sediment = hydrology.sediment_load
        let excess = sediment - config.hydrology.sediment_lithification.threshold
        let lithified = excess * config.hydrology.sediment_lithification.rate_per_myr * 1e-6
        hydrology.sediment_load <- -lithified
    }
}

# =============================================================================
# Hydrology Cell Entity (Spatial Water Samples)
# =============================================================================
# 
# Per-sample water state for spatially-resolved hydrology modeling
# Similar to terra.plate entity for geophysics, this represents discrete
# water samples on the planetary surface that can track local water state,
# temperature, phase transitions, and sediment load.

entity hydrology.cell {
    : count(config.hydrology.cell_count)
    : count_bounds(100, 10000)

    signal water_mass {
        : Scalar<kg/m², 0..1e6>
        : uses(maths.clamping)
        : stratum(hydrology)
        : title("Cell Water Mass")
        : symbol("m_w")
    
        config {
            initial_water_mass: 1e3
        }
    
        initial { config.hydrology.cell.water_mass.initial_water_mass }
    
        resolve {
            # Water mass changes from precipitation, evaporation, runoff
            # Net rate integrated over time
            maths.clamp(prev + inputs, 0.0, 1e6)
        }
    
        assert {
            prev >= 0.0 : warn, "Cell water mass cannot be negative"
            prev <= 1e6 : warn, "Cell water mass exceeds maximum"
        }
    }

    signal temperature {
        : Scalar<K, 271..313>
        : uses(maths.clamping)
        : stratum(hydrology)
        : title("Cell Water Temperature")
        : symbol("T_w")
    
        config {
            initial_temperature_k: 288.0
            relaxation_tau_s: 8.64e4  # ~1 day relaxation time
        }
    
        initial { config.hydrology.cell.temperature.initial_temperature_k }
    
        resolve {
            # Water temperature relaxes toward surface temperature
            let surface_temp = surface.temp in
            let target_temp = maths.clamp(surface_temp, 271.0, 313.0) in
            dt.relax_to(prev, target_temp, config.hydrology.cell.temperature.relaxation_tau_s) + inputs
        }
    
        assert {
            prev >= 271.0 : warn, "Water temperature below freezing minimum"
            prev <= 313.0 : warn, "Water temperature above maximum"
        }
    }

    signal sediment_mass {
        : Scalar<kg/m², 0..10>
        : uses(maths.clamping)
        : stratum(hydrology)
        : title("Cell Sediment Mass")
        : symbol("m_s")
    
        config {
            initial_sediment: 0.2
            max_sediment: 10.0
        }
    
        initial { config.hydrology.cell.sediment_mass.initial_sediment }
    
        resolve {
            # Sediment mass changes via erosion, transport, and deposition
            maths.clamp(prev + inputs, 0.0, config.hydrology.cell.sediment_mass.max_sediment)
        }
    
        assert {
            prev >= 0.0 : warn, "Sediment mass cannot be negative"
            prev <= config.hydrology.cell.sediment_mass.max_sediment : warn, "Sediment mass exceeds maximum"
        }
    }

    signal ice_fraction {
        : Scalar<1, 0..1>
        : uses(maths.clamping)
        : stratum(hydrology)
        : title("Cell Ice Fraction")
        : symbol("f_ice")
    
        config {
            freezing_point_k: 273.15
            transition_width_k: 2.0
        }
    
        initial { 0.0 }
    
        resolve {
            # Ice fraction determined by water temperature
            let temp = self.temperature in
            let t_freeze = config.hydrology.cell.ice_fraction.freezing_point_k in
            let width = config.hydrology.cell.ice_fraction.transition_width_k in
    
            if temp <= t_freeze - width {
                # Fully frozen
                1.0
            } else if temp >= t_freeze + width {
                # Fully liquid
                0.0
            } else {
                # Smooth transition
                let normalized = (temp - (t_freeze - width)) / (2.0 * width) in
                maths.clamp(1.0 - normalized, 0.0, 1.0)
            }
        }
    
        assert {
            prev >= 0.0 : warn, "Ice fraction cannot be negative"
            prev <= 1.0 : warn, "Ice fraction cannot exceed 1"
        }
    }

    signal phase {
        : Scalar<1, 0..2>
        : stratum(hydrology)
        : title("Cell Water Phase")
        : symbol("phi")
    
        resolve {
            # Phase determined from temperature
            let temp = self.temperature in
            hydrology.water_phase(temp)
        }
    
        assert {
            prev >= 0.0 : warn, "Phase indicator below minimum"
            prev <= 2.0 : warn, "Phase indicator above maximum"
        }
    }

}

# -----------------------------------------------------------------------------
# Per-Cell Water State Members
# -----------------------------------------------------------------------------

# Water column mass per unit area (kg/m²)
# Represents the total mass of water (liquid + ice) at this cell

# Water temperature (K)
# Local water body temperature - can differ from surface temp

# Suspended sediment mass per unit area (kg/m²)
# Particulate matter suspended in the water column

# Ice fraction (0-1)
# Fraction of water mass that is frozen

# Water phase state (enumerated: 0=ice, 1=liquid, 2=vapor)
# Dominant phase at this cell

# -----------------------------------------------------------------------------
# Aggregate Cell Signals
# Spatial statistics derived from the cell population
# -----------------------------------------------------------------------------

# Total water mass across all cells
signal hydrology.cells.total_water {
    : Scalar<kg, 0..1e20>
    : stratum(hydrology)
    : title("Total Cell Water Mass")
    : symbol("M_total")

    resolve {
        agg.sum(entity.hydrology.cell, self.water_mass)
    }
}

# Mean water temperature
signal hydrology.cells.mean_temperature {
    : Scalar<K, 271..313>
    : stratum(hydrology)
    : title("Mean Cell Temperature")
    : symbol("T_mean")

    resolve {
        agg.mean(entity.hydrology.cell, self.temperature)
    }
}

# Total sediment load
signal hydrology.cells.total_sediment {
    : Scalar<kg/m², 0..10000>
    : stratum(hydrology)
    : title("Total Cell Sediment")
    : symbol("S_total")

    resolve {
        agg.sum(entity.hydrology.cell, self.sediment_mass)
    }
}

# Mean ice fraction (global ice coverage proxy)
signal hydrology.cells.mean_ice_fraction {
    : Scalar<1, 0..1>
    : stratum(hydrology)
    : title("Mean Ice Fraction")
    : symbol("f_ice_mean")

    resolve {
        agg.mean(entity.hydrology.cell, self.ice_fraction)
    }
}

# Count of frozen cells (ice phase dominant)
signal hydrology.cells.frozen_count {
    : Scalar<1, 0..10000>
    : stratum(hydrology)
    : title("Frozen Cell Count")
    : symbol("N_ice")

    resolve {
        agg.sum(entity.hydrology.cell, if self.phase < 0.5 { 1.0 } else { 0.0 })
    }
}

# Count of liquid cells
signal hydrology.cells.liquid_count {
    : Scalar<1, 0..10000>
    : stratum(hydrology)
    : title("Liquid Cell Count")
    : symbol("N_liquid")

    resolve {
        agg.sum(entity.hydrology.cell, if self.phase >= 0.5 and self.phase < 1.5 { 1.0 } else { 0.0 })
    }
}

# =============================================================================
# Hydrology Fields
# =============================================================================
# 
# Observer-only fields for visualization and analysis of hydrology state.
# These fields sample from hydrology.cell entity members to provide
# spatially-resolved observations of water distribution, temperature, phase,
# sediment transport, and flow dynamics.

# -----------------------------------------------------------------------------
# Global Scalar Fields (Signal-based)
# These sample from global hydrology signals
# -----------------------------------------------------------------------------

field hydrology.water_mass_map {
    : Scalar<kg>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Water Mass Field")

    measure {
        hydrology.water_mass
    }
}

field hydrology.water_presence {
    : Scalar<1>
    : stratum(hydrology)
    : uses(maths.clamping)
    : topology(sphere_surface)
    : title("Water Presence")

    measure {
        hydrology.water_presence(hydrology.water_mass, const.hydrology.reference_water_mass_kg)
    }
}

field hydrology.ice_map {
    : Scalar<kg>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Ice Mass Field")

    measure {
        hydrology.ice_mass
    }
}

field hydrology.evaporation {
    : Scalar<kg/m²/s>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Evaporation Rate Field")

    measure {
        hydrology.evaporation_rate
    }
}

field hydrology.precipitation {
    : Scalar<kg/m²/s>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Precipitation Rate Field")

    measure {
        hydrology.precipitation_rate
    }
}

field hydrology.runoff {
    : Scalar<kg/s>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Runoff Accumulation Field")

    measure {
        hydrology.runoff_accumulation
    }
}

field hydrology.sediment {
    : Scalar<kg/m²>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Sediment Load Field")

    measure {
        hydrology.sediment_load
    }
}

field hydrology.weathering {
    : Scalar<kg/m²/yr>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Chemical Weathering Field")

    measure {
        hydrology.chemical_weathering
    }
}

field hydrology.water_phase {
    : Scalar<1>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Water Phase Field")

    measure {
        hydrology.water_phase(surface.temp)
    }
}

field hydrology.water_temperature_map {
    : Scalar<K>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Water Temperature Field")

    measure {
        hydrology.water_temperature
    }
}

field hydrology.groundwater_saturation_map {
    : Scalar<1>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Groundwater Saturation Field")

    measure {
        hydrology.groundwater_saturation
    }
}

field hydrology.infiltration_map {
    : Scalar<kg/m²/s>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Infiltration Rate Field")

    measure {
        hydrology.infiltration_rate
    }
}

field hydrology.baseflow_map {
    : Scalar<kg/m²/s>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Baseflow Rate Field")

    measure {
        hydrology.baseflow_rate
    }
}

field hydrology.dissolved_gas_map {
    : Scalar<mol/m³>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Dissolved Gas Field")

    measure {
        hydrology.dissolved_gas
    }
}

field hydrology.flow_accumulation_map {
    : Scalar<1>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Flow Accumulation Field")

    measure {
        hydrology.flow_accumulation
    }
}

field hydrology.stream_order_map {
    : Scalar<1>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Stream Order Field")

    measure {
        hydrology.stream_order
    }
}

# -----------------------------------------------------------------------------
# Spatially-Resolved Cell Fields (Entity-based)
# These sample from hydrology.cell entity members for per-location observations
# -----------------------------------------------------------------------------

# Per-cell water mass distribution
# in the hydrology.cell members. This field measures runoff accumulation
# as a proxy for flow dynamics.
field hydrology.flow_velocity_field {
    : Scalar<kg/s>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Flow Velocity Proxy Field")

    measure {
        hydrology.runoff_accumulation
    }
}

# Drainage network field
# Measures flow accumulation which traces drainage paths
field hydrology.drainage_network_field {
    : Scalar<1>
    : stratum(hydrology)
    : topology(sphere_surface)
    : title("Drainage Network Field")

    measure {
        hydrology.flow_accumulation
    }
}
