# Terra Hydrology Module
# Water cycle: precipitation, evaporation, runoff, and sediment transport
#
# This module handles the hydrological cycle and surface water dynamics.
# Depends on atmosphere for temperature and precipitation drivers.
# =============================================================================

# =============================================================================
# Hydrology Constants
# =============================================================================

const {
    # Water phase boundaries (K at 1 atm)
    hydrology.freezing_point_k: 273.15
    hydrology.boiling_point_k: 373.15

    # Latent heats (J/kg)
    hydrology.latent_heat_vaporization: 2.45e6
    hydrology.latent_heat_sublimation: 2.83e6
    hydrology.latent_heat_fusion: 3.34e5

    # Physical constants
    hydrology.psychrometric_constant: 0.066     # kPa/K
    hydrology.priestley_taylor_alpha: 1.26      # PT coefficient

    # Sediment
    hydrology.max_sediment_load: 10.0           # Maximum sediment capacity

    # Reference values
    hydrology.reference_water_mass_kg: 1e8      # kg per cell for "saturated"
}

# =============================================================================
# Hydrology Configuration
# =============================================================================

config {
    # Evaporation
    hydrology.evaporation_coefficient: 1.0
    hydrology.bulk_transfer_coefficient: 1.5e-3
    hydrology.wind_speed_m_s: 5.0

    # Precipitation
    hydrology.base_precipitation_rate: 1e-5     # kg/m²/s base rate
    hydrology.orographic_factor: 2.0            # Enhancement on windward slopes
    hydrology.rain_shadow_factor: 0.3           # Reduction on leeward slopes

    # Runoff
    hydrology.runoff_coefficient: 0.3
    hydrology.infiltration_rate: 1e-6           # m/s

    # Sediment transport
    hydrology.erosion_rate: 1e-6                # m/s base erosion
    hydrology.deposition_rate: 1e-7             # m/s base deposition
    hydrology.sediment_capacity_factor: 1.0

    # Ice/glacier
    hydrology.ice_flow_rate: 1e-10              # m/s base glacial flow
    hydrology.sublimation_rate: 1e-8            # kg/m²/s sublimation rate

    # Initial values
    hydrology.initial_water_mass: 1e6
    hydrology.initial_ice_mass: 0.0
    hydrology.initial_sediment_load: 0.2
    hydrology.initial_runoff_accumulation: 0.0
    hydrology.initial_evaporation_rate: 1e-6
    hydrology.initial_precipitation_rate: 1e-5
}

# =============================================================================
# Hydrology Functions
# =============================================================================

# Determine water phase from temperature
fn.hydrology.water_phase(temperature_k) {
    if temperature_k < 273.15 {
        0.0  # Ice
    } else {
        if temperature_k < 373.15 {
            1.0  # Liquid
        } else {
            2.0  # Vapor
        }
    }
}

# Saturation vapor pressure (simplified)
fn.hydrology.saturation_vapor_pressure(temperature_k) {
    let t_celsius = temperature_k - 273.15 in
    610.94 * exp((17.625 * t_celsius) / (t_celsius + 243.04))
}

# Water presence from mass (normalized 0-1)
fn.hydrology.water_presence(water_mass_kg, reference_mass_kg) {
    clamp(water_mass_kg / reference_mass_kg, 0.0, 1.0)
}

# =============================================================================
# Surface Water Signals
# =============================================================================

# Global water mass budget
signal.hydrology.water_mass {
    : Scalar<kg, 0..1e20>
    : strata(hydrology)
    : title("Total Surface Water Mass")
    : symbol("M_water")

    config {
        initial: 1e18
        min: 0.0
        max: 1e20
    }

    resolve {
        # Water budget: precipitation - evaporation + external inputs
        # Net rate = (precip - evap) * surface_area
        let net_rate = (signal.hydrology.precipitation_rate - signal.hydrology.evaporation_rate) * 5.1e14 in
        clamp(kernel.integrate(prev, net_rate) + collected, config.hydrology.water_mass.min, config.hydrology.water_mass.max)
    }

    assert {
        prev >= 0.0 : warn, "Water mass cannot be negative"
    }
}

# Ice mass (glaciers, ice sheets)
signal.hydrology.ice_mass {
    : Scalar<kg, 0..1e19>
    : strata(hydrology)
    : title("Total Ice Mass")
    : symbol("M_ice")

    config {
        initial: 2.6e19  # Earth's ice mass ~26 million km³
        sublimation_rate: 1e-8
    }

    resolve {
        # Ice mass changes through freezing/melting and sublimation
        let temp = signal.surface.temp in
        let phase = hydrology.water_phase(temp) in

        if phase < 0.5 {
            # Freezing conditions - ice can accumulate
            prev + collected
        } else {
            # Melting/sublimation conditions - sublimation rate * area
            let sublimation_rate = config.hydrology.ice_mass.sublimation_rate * 1e13 in
            max(kernel.integrate(prev, -sublimation_rate) + collected, 0.0)
        }
    }

    assert {
        prev >= 0.0 : warn, "Ice mass cannot be negative"
    }
}

# =============================================================================
# Evaporation
# =============================================================================

signal.hydrology.evaporation_rate {
    : Scalar<kg/m²/s, 0..1e-3>
    : strata(hydrology)
    : title("Evaporation Rate")
    : symbol("E")

    config {
        bulk_transfer: 1.5e-3
        wind_speed: 5.0
        min: 0.0
        max: 1e-3
    }

    resolve {
        # Bulk aerodynamic formula: E = C_E * U * (q_sat - q_air)
        let temp = signal.surface.temp in
        let phase = hydrology.water_phase(temp) in

        if phase > 0.5 && phase < 1.5 {
            # Liquid water - normal evaporation
            let e_sat = hydrology.saturation_vapor_pressure(temp) in
            let q_sat = 0.622 * e_sat / 101325.0 in  # Mixing ratio at saturation
            let q_air = q_sat * 0.6 in                # Assume 60% RH
            let evap = config.hydrology.evaporation_rate.bulk_transfer * config.hydrology.evaporation_rate.wind_speed * (q_sat - q_air) * 1.2 in
            clamp(evap + collected, config.hydrology.evaporation_rate.min, config.hydrology.evaporation_rate.max)
        } else {
            # Ice or vapor - reduced/no evaporation
            collected
        }
    }

    assert {
        prev >= 0.0 : warn, "Evaporation rate cannot be negative"
    }
}

# =============================================================================
# Precipitation
# =============================================================================

signal.hydrology.precipitation_rate {
    : Scalar<kg/m²/s, 0..1e-2>
    : strata(hydrology)
    : title("Precipitation Rate")
    : symbol("P")

    config {
        base_rate: 1e-5
        water_vapor_sensitivity: 1e-6
        min: 0.0
        max: 1e-2
    }

    resolve {
        # Precipitation depends on water vapor availability
        let water_vapor = signal.atmosphere.water_vapor in
        let precip = config.hydrology.precipitation_rate.base_rate + water_vapor * config.hydrology.precipitation_rate.water_vapor_sensitivity in
        clamp(precip + collected, config.hydrology.precipitation_rate.min, config.hydrology.precipitation_rate.max)
    }

    assert {
        prev >= 0.0 : warn, "Precipitation rate cannot be negative"
    }
}

# =============================================================================
# Runoff and Flow
# =============================================================================

signal.hydrology.runoff_accumulation {
    : Scalar<kg/s, 0..1e15>
    : strata(hydrology)
    : title("Runoff Accumulation")
    : symbol("Q")

    config {
        coefficient: 0.3
        min: 0.0
        max: 1e15
    }

    resolve {
        # Runoff = precipitation * runoff_coefficient * area
        let precip = signal.hydrology.precipitation_rate in
        let evap = signal.hydrology.evaporation_rate in
        let net_water = max(precip - evap, 0.0) in
        let runoff = net_water * config.hydrology.runoff_accumulation.coefficient * 5.1e14 in

        clamp(runoff + collected, config.hydrology.runoff_accumulation.min, config.hydrology.runoff_accumulation.max)
    }

    assert {
        prev >= 0.0 : warn, "Runoff cannot be negative"
    }
}

# =============================================================================
# Sediment Transport
# =============================================================================

signal.hydrology.sediment_load {
    : Scalar<kg/m², 0..10>
    : strata(hydrology)
    : title("Sediment Load")
    : symbol("S")

    config {
        erosion_rate: 1e-6
        deposition_rate: 1e-7
        max_load: 10.0
    }

    resolve {
        # Sediment transport depends on runoff and slope
        let runoff = signal.hydrology.runoff_accumulation in
        let erosion_rate = runoff * config.hydrology.sediment_load.erosion_rate / 1e12 in
        let deposition_rate = prev * config.hydrology.sediment_load.deposition_rate in
        let net_rate = erosion_rate - deposition_rate in

        clamp(kernel.integrate(prev, net_rate) + collected, 0.0, config.hydrology.sediment_load.max_load)
    }

    assert {
        prev >= 0.0 : warn, "Sediment load cannot be negative"
        prev <= const.hydrology.max_sediment_load : warn, "Sediment load exceeds maximum"
    }
}

# =============================================================================
# Weathering (Chemical erosion)
# =============================================================================

signal.hydrology.chemical_weathering {
    : Scalar<kg/m²/yr, 0..1>
    : strata(hydrology)
    : title("Chemical Weathering Rate")
    : symbol("W_chem")

    config {
        base_rate: 0.01
        temperature_sensitivity: 0.05
        runoff_sensitivity: 1e-16
        co2_sensitivity: 0.001
    }

    resolve {
        # Weathering increases with temperature, runoff, and CO2
        let temp = signal.surface.temp in
        let runoff = signal.hydrology.runoff_accumulation in
        let co2 = signal.atmosphere.co2_ppmv in

        let temp_factor = exp(config.hydrology.chemical_weathering.temperature_sensitivity * (temp - 288.0)) in
        let runoff_factor = 1.0 + runoff * config.hydrology.chemical_weathering.runoff_sensitivity in
        let co2_factor = 1.0 + (co2 - 280.0) * config.hydrology.chemical_weathering.co2_sensitivity in

        clamp(config.hydrology.chemical_weathering.base_rate * temp_factor * runoff_factor * co2_factor + collected, 0.0, 1.0)
    }

    assert {
        prev >= 0.0 : warn, "Weathering rate cannot be negative"
    }
}

# =============================================================================
# Water Temperature
# =============================================================================

signal.hydrology.water_temperature {
    : Scalar<K, 271..313>
    : strata(hydrology)
    : title("Surface Water Temperature")
    : symbol("T_w")

    config {
        relaxation_tau_s: 3.1536e7       # ~1 year relaxation time
        latitude_adjustment: 10.0         # K difference pole to equator
        min_temp_k: 271.0                 # Just above freezing
        max_temp_k: 313.0                 # ~40°C ocean surface max
    }

    resolve {
        # Water temperature relaxes toward surface temperature with latitude adjustment
        let surface_temp = signal.surface.temp in
        let target_temp = clamp(surface_temp, config.hydrology.water_temperature.min_temp_k, config.hydrology.water_temperature.max_temp_k) in
        relax_to(prev, target_temp, config.hydrology.water_temperature.relaxation_tau_s) + collected
    }

    assert {
        prev >= config.hydrology.water_temperature.min_temp_k : warn, "Water temperature too low"
        prev <= config.hydrology.water_temperature.max_temp_k : warn, "Water temperature too high"
    }
}

# =============================================================================
# Groundwater System
# =============================================================================

# Groundwater saturation fraction
signal.hydrology.groundwater_saturation {
    : Scalar<1, 0..1>
    : strata(hydrology)
    : title("Groundwater Saturation")
    : symbol("S_gw")

    config {
        initial: 0.5
        porosity: 0.3                     # Typical soil porosity
        max_capacity_kg_m2: 1e5           # Maximum water per unit area
    }

    resolve {
        # Saturation changes from infiltration (increase) and baseflow (decrease)
        let infiltration = signal.hydrology.infiltration_rate in
        let baseflow = signal.hydrology.baseflow_rate in
        let net_rate = (infiltration - baseflow) / config.hydrology.groundwater_saturation.max_capacity_kg_m2 in
        clamp(kernel.integrate(prev, net_rate) + collected, 0.0, 1.0)
    }

    assert {
        prev >= 0.0 : warn, "Groundwater saturation cannot be negative"
        prev <= 1.0 : warn, "Groundwater saturation cannot exceed 1"
    }
}

# Infiltration rate from surface to groundwater
signal.hydrology.infiltration_rate {
    : Scalar<kg/m²/s, 0..1e-2>
    : strata(atmosphere)
    : title("Infiltration Rate")
    : symbol("I")

    config {
        permeability_m_per_s: 1e-6        # Mixed regolith/soil
        min_surface_water_kg: 1000.0      # Minimum surface water to infiltrate
        max_rate: 2.8e-3                  # Max ~10 mm/hour
        water_density: 1000.0             # kg/m³
    }

    resolve {
        # Green-Ampt simplified: infiltration limited by available pore space
        let saturation = signal.hydrology.groundwater_saturation in
        let available_pore = max(1.0 - saturation, 0.0) * 0.3 in  # porosity = 0.3
        let rate_m_per_s = config.hydrology.infiltration_rate.permeability_m_per_s * available_pore in
        let rate_kg = rate_m_per_s * config.hydrology.infiltration_rate.water_density in
        clamp(rate_kg + collected, 0.0, config.hydrology.infiltration_rate.max_rate)
    }

    assert {
        prev >= 0.0 : warn, "Infiltration rate cannot be negative"
    }
}

# Baseflow rate from groundwater to surface streams
signal.hydrology.baseflow_rate {
    : Scalar<kg/m²/s, 0..1e-3>
    : strata(atmosphere)
    : title("Baseflow Rate")
    : symbol("Q_base")

    config {
        threshold: 0.7                    # Saturation threshold for baseflow
        coefficient: 1e-6                 # Discharge coefficient (1/s)
        max_rate: 1e-3
    }

    resolve {
        # Darcy-like: baseflow when saturation exceeds threshold
        let saturation = signal.hydrology.groundwater_saturation in
        let excess = max(saturation - config.hydrology.baseflow_rate.threshold, 0.0) in
        let rate = excess * config.hydrology.baseflow_rate.coefficient * 1e5 in  # scaled by capacity
        clamp(rate + collected, 0.0, config.hydrology.baseflow_rate.max_rate)
    }

    assert {
        prev >= 0.0 : warn, "Baseflow rate cannot be negative"
    }
}

# =============================================================================
# Dissolved Content
# =============================================================================

# Dissolved gas in surface water
signal.hydrology.dissolved_gas {
    : Scalar<mol/m³, 0..100>
    : strata(hydrology)
    : title("Dissolved Gas Content")
    : symbol("G")

    config {
        initial: 10.0                     # mol/m³ proxy
        exchange_rate: 1e-7               # Gas exchange rate with atmosphere
        temperature_sensitivity: -0.02    # Solubility decreases with temperature
    }

    resolve {
        # Dissolved gas depends on temperature and atmospheric exchange
        let temp = signal.hydrology.water_temperature in
        let temp_factor = exp(config.hydrology.dissolved_gas.temperature_sensitivity * (temp - 288.0)) in
        let equilibrium = config.hydrology.dissolved_gas.initial * temp_factor in
        relax_to(prev, equilibrium, 3.1536e7) + collected
    }

    assert {
        prev >= 0.0 : warn, "Dissolved gas cannot be negative"
    }
}

# =============================================================================
# Flow Topology
# =============================================================================

# Flow accumulation (upstream contributing area proxy)
signal.hydrology.flow_accumulation {
    : Scalar<1, 0..1e6>
    : strata(hydrology)
    : title("Flow Accumulation")
    : symbol("A_flow")

    config {
        base_value: 1.0
        runoff_sensitivity: 1e-14
    }

    resolve {
        # Flow accumulation scales with runoff
        let runoff = signal.hydrology.runoff_accumulation in
        config.hydrology.flow_accumulation.base_value + runoff * config.hydrology.flow_accumulation.runoff_sensitivity + collected
    }

    assert {
        prev >= 0.0 : warn, "Flow accumulation cannot be negative"
    }
}

# Stream order (Strahler)
signal.hydrology.stream_order {
    : Scalar<1, 0..10>
    : strata(hydrology)
    : title("Stream Order")
    : symbol("ω")

    config {
        flow_threshold: 100.0             # Flow accumulation for stream initiation
    }

    resolve {
        # Simplified stream order from flow accumulation
        let flow_acc = signal.hydrology.flow_accumulation in
        if flow_acc < config.hydrology.stream_order.flow_threshold {
            0.0  # Hillslope
        } else {
            clamp(log10(flow_acc / config.hydrology.stream_order.flow_threshold) + 1.0, 0.0, 10.0)
        }
    }

    assert {
        prev >= 0.0 : warn, "Stream order cannot be negative"
        prev <= 10.0 : warn, "Stream order exceeds maximum"
    }
}

# =============================================================================
# Hydrology Fractures
# =============================================================================

# Flash flood: sudden high precipitation
fracture.hydrology.flash_flood {
    when {
        signal.hydrology.precipitation_rate > 5e-4
        signal.hydrology.runoff_accumulation > 1e14
    }

    emit {
        signal.hydrology.sediment_load <- 1.0
        signal.hydrology.runoff_accumulation <- -signal.hydrology.runoff_accumulation * 0.5
    }
}

# Drought: prolonged low precipitation
fracture.hydrology.drought {
    when {
        signal.hydrology.precipitation_rate < 1e-6
        signal.hydrology.water_mass < 1e17
    }

    emit {
        signal.hydrology.evaporation_rate <- -signal.hydrology.evaporation_rate * 0.5
    }
}

# Glacial surge
fracture.hydrology.glacial_surge {
    when {
        signal.hydrology.ice_mass > 3e19
        signal.surface.temp < 270.0 <K>
    }

    emit {
        signal.hydrology.ice_mass <- -1e18
        signal.hydrology.sediment_load <- 2.0
    }
}

# -----------------------------------------------------------------------------
# Process-Based Hydrology Fractures
# -----------------------------------------------------------------------------

# Precipitation coupling: equilibrium-based water redistribution
# Relaxes surface water toward orographically-weighted equilibrium
fracture.hydrology.precipitation_coupling {
    : strata(hydrology)

    config {
        global_equilibrium_kg: 1e6          # Target equilibrium per cell
        orographic_weight_scale: 1.5        # Enhancement factor for elevated terrain
        relaxation_timescale_s: 3.1536e8    # ~10 year relaxation (geological scale)
    }

    when {
        signal.hydrology.water_mass > 0.0
    }

    emit {
        # Water redistributes toward equilibrium based on terrain
        # Higher elevations get orographic enhancement (windward precipitation)
        let equilibrium = config.fracture.hydrology.precipitation_coupling.global_equilibrium_kg in
        let current = signal.hydrology.water_mass in
        let deviation = current / (current + equilibrium) - 0.5 in
        signal.hydrology.water_mass <- -deviation * current * 0.01
    }
}

# Hydraulic erosion: stream power erosion model
# E = K * A^m * S^n (stream power law)
fracture.hydrology.hydraulic_erosion {
    : strata(hydrology)

    config {
        erodibility: 1e-6                   # K coefficient (m/Myr)
        m_exponent: 0.5                     # Area exponent (typically 0.4-0.6)
        n_exponent: 1.0                     # Slope exponent (typically 1.0)
        erosion_threshold: 100.0            # Min flow accumulation for erosion
        max_erosion_rate_m_per_myr: 1000.0  # Cap erosion rate
        sediment_conversion: 1.0            # Eroded material → sediment
    }

    when {
        signal.hydrology.flow_accumulation > config.fracture.hydrology.hydraulic_erosion.erosion_threshold
        signal.hydrology.runoff_accumulation > 1e10
    }

    emit {
        # Stream power erosion: E = K * A^m * S^n
        let flow_acc = signal.hydrology.flow_accumulation in
        let erosion_factor = config.fracture.hydrology.hydraulic_erosion.erodibility * pow(flow_acc, config.fracture.hydrology.hydraulic_erosion.m_exponent) in
        let erosion_rate = min(erosion_factor, config.fracture.hydrology.hydraulic_erosion.max_erosion_rate_m_per_myr) in

        # Eroded material becomes sediment
        signal.hydrology.sediment_load <- erosion_rate * config.fracture.hydrology.hydraulic_erosion.sediment_conversion * 1e-6
    }
}

# Sediment transport: routes sediment downstream along drainage network
# When transport capacity exceeded, sediment deposits
fracture.hydrology.sediment_transport {
    : strata(hydrology)

    config {
        capacity_coefficient: 1e-4          # Transport capacity coefficient
        discharge_exponent: 0.6             # Discharge influence on capacity
        deposition_rate: 0.1                # Fraction of excess deposited per timestep
    }

    when {
        signal.hydrology.sediment_load > 0.1
        signal.hydrology.runoff_accumulation > 1e8
    }

    emit {
        # Transport capacity: C = K * Q^a
        let discharge = signal.hydrology.runoff_accumulation in
        let capacity = config.fracture.hydrology.sediment_transport.capacity_coefficient * pow(discharge, config.fracture.hydrology.sediment_transport.discharge_exponent) in
        let sediment = signal.hydrology.sediment_load in

        # If sediment > capacity, deposit excess
        let excess = max(sediment - capacity * 1e-10, 0.0) in
        let deposition = excess * config.fracture.hydrology.sediment_transport.deposition_rate in
        signal.hydrology.sediment_load <- -deposition
    }
}

# Water thermal relaxation: couples water temperature to climate
# Water temperature relaxes toward surface temperature with latitude adjustment
fracture.hydrology.water_thermal_relaxation {
    : strata(hydrology)

    config {
        relaxation_timescale_s: 3.1536e7    # ~1 year relaxation
        pole_to_equator_gradient_k: 30.0    # Temperature gradient
        min_water_temp_k: 271.0             # Just above freezing
        max_water_temp_k: 313.0             # ~40C ocean surface max
    }

    when {
        signal.hydrology.water_mass > 1e10
    }

    emit {
        # Water temperature relaxes toward climate-adjusted equilibrium
        let surface_temp = signal.surface.temp in
        let target = clamp(surface_temp, config.fracture.hydrology.water_thermal_relaxation.min_water_temp_k, config.fracture.hydrology.water_thermal_relaxation.max_water_temp_k) in
        let current = signal.hydrology.water_temperature in
        let delta = (target - current) * 0.01 in
        signal.hydrology.water_temperature <- delta
    }
}

# Dissolved gas exchange: temperature-dependent gas solubility
# Cold water dissolves more gas, warm water releases gas
fracture.hydrology.gas_exchange {
    : strata(hydrology)

    config {
        solubility_cold: 0.7                # Equilibrium at cold water (~270K)
        solubility_warm: 0.3                # Equilibrium at warm water (~300K)
        cold_temp_k: 270.0
        warm_temp_k: 300.0
        exchange_timescale_s: 6.048e5       # ~7 days exchange timescale
    }

    when {
        signal.hydrology.water_mass > 1e10
    }

    emit {
        # Gas solubility inversely related to temperature (Henry's law)
        let temp = signal.hydrology.water_temperature in
        let temp_fraction = clamp((temp - config.fracture.hydrology.gas_exchange.cold_temp_k) / (config.fracture.hydrology.gas_exchange.warm_temp_k - config.fracture.hydrology.gas_exchange.cold_temp_k), 0.0, 1.0) in
        let target_gas = config.fracture.hydrology.gas_exchange.solubility_cold * (1.0 - temp_fraction) + config.fracture.hydrology.gas_exchange.solubility_warm * temp_fraction in
        let current_gas = signal.hydrology.dissolved_gas in
        let delta = (target_gas * 10.0 - current_gas) * 0.001 in
        signal.hydrology.dissolved_gas <- delta
    }
}

# Groundwater coupling: infiltration and baseflow
# Bidirectional water transfer between surface and crust water reservoir
fracture.hydrology.groundwater_coupling {
    : strata(hydrology)

    config {
        # Infiltration parameters
        permeability_m_per_s: 1e-6          # Mixed regolith/soil permeability
        porosity: 0.3                       # Typical soil porosity
        min_surface_water_kg: 1000.0        # Min surface water for infiltration

        # Baseflow parameters
        baseflow_threshold: 0.7             # Saturation threshold for baseflow
        baseflow_coefficient: 1e-6          # Discharge coefficient (1/s)
    }

    when {
        signal.hydrology.water_mass > config.fracture.hydrology.groundwater_coupling.min_surface_water_kg
    }

    emit {
        # Infiltration: surface -> groundwater when pore space available
        let saturation = signal.hydrology.groundwater_saturation in
        let available_pore = max(1.0 - saturation, 0.0) * config.fracture.hydrology.groundwater_coupling.porosity in
        let infiltration_rate = config.fracture.hydrology.groundwater_coupling.permeability_m_per_s * available_pore * 1000.0 in

        # Baseflow: groundwater -> surface when saturated
        let excess = max(saturation - config.fracture.hydrology.groundwater_coupling.baseflow_threshold, 0.0) in
        let baseflow_rate = excess * config.fracture.hydrology.groundwater_coupling.baseflow_coefficient * 1e5 in

        # Net exchange
        let net_surface = baseflow_rate - infiltration_rate in
        signal.hydrology.groundwater_saturation <- -net_surface * 1e-5
    }
}

# Sediment lithification: converts thick sediment to crustal rock
# Prevents sediment saturation, creates sedimentary basins
fracture.hydrology.sediment_lithification {
    : strata(hydrology)

    config {
        threshold: 6.0                      # Sediment threshold for lithification
        rate_per_myr: 0.15                  # 15% of excess lithifies per Myr
        sediment_to_rock_m: 500.0           # 1 sediment unit -> 500m rock
        max_elevation_m: -500.0             # Only in basins (below sea level)
    }

    when {
        signal.hydrology.sediment_load > config.fracture.hydrology.sediment_lithification.threshold
    }

    emit {
        # Excess sediment above threshold compacts and lithifies
        let sediment = signal.hydrology.sediment_load in
        let excess = sediment - config.fracture.hydrology.sediment_lithification.threshold in
        let lithified = excess * config.fracture.hydrology.sediment_lithification.rate_per_myr * 1e-6 in
        signal.hydrology.sediment_load <- -lithified
    }
}

# =============================================================================
# Hydrology Fields
# =============================================================================

field.hydrology.water_mass_map {
    : Scalar<kg>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Water Mass Field")

    measure {
        signal.hydrology.water_mass
    }
}

field.hydrology.water_presence {
    : Scalar<1>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Water Presence")

    measure {
        hydrology.water_presence(signal.hydrology.water_mass, const.hydrology.reference_water_mass_kg)
    }
}

field.hydrology.ice_map {
    : Scalar<kg>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Ice Mass Field")

    measure {
        signal.hydrology.ice_mass
    }
}

field.hydrology.evaporation {
    : Scalar<kg/m²/s>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Evaporation Rate Field")

    measure {
        signal.hydrology.evaporation_rate
    }
}

field.hydrology.precipitation {
    : Scalar<kg/m²/s>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Precipitation Rate Field")

    measure {
        signal.hydrology.precipitation_rate
    }
}

field.hydrology.runoff {
    : Scalar<kg/s>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Runoff Accumulation Field")

    measure {
        signal.hydrology.runoff_accumulation
    }
}

field.hydrology.sediment {
    : Scalar<kg/m²>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Sediment Load Field")

    measure {
        signal.hydrology.sediment_load
    }
}

field.hydrology.weathering {
    : Scalar<kg/m²/yr>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Chemical Weathering Field")

    measure {
        signal.hydrology.chemical_weathering
    }
}

field.hydrology.water_phase {
    : Scalar<1>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Water Phase Field")

    measure {
        hydrology.water_phase(signal.surface.temp)
    }
}

field.hydrology.water_temperature_map {
    : Scalar<K>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Water Temperature Field")

    measure {
        signal.hydrology.water_temperature
    }
}

field.hydrology.groundwater_saturation_map {
    : Scalar<1>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Groundwater Saturation Field")

    measure {
        signal.hydrology.groundwater_saturation
    }
}

field.hydrology.infiltration_map {
    : Scalar<kg/m²/s>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Infiltration Rate Field")

    measure {
        signal.hydrology.infiltration_rate
    }
}

field.hydrology.baseflow_map {
    : Scalar<kg/m²/s>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Baseflow Rate Field")

    measure {
        signal.hydrology.baseflow_rate
    }
}

field.hydrology.dissolved_gas_map {
    : Scalar<mol/m³>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Dissolved Gas Field")

    measure {
        signal.hydrology.dissolved_gas
    }
}

field.hydrology.flow_accumulation_map {
    : Scalar<1>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Flow Accumulation Field")

    measure {
        signal.hydrology.flow_accumulation
    }
}

field.hydrology.stream_order_map {
    : Scalar<1>
    : strata(hydrology)
    : topology(sphere_surface)
    : title("Stream Order Field")

    measure {
        signal.hydrology.stream_order
    }
}
