# Terra Atmosphere Module
# Atmospheric physics: radiative transfer, water vapor feedback, clouds
#
# This module handles atmospheric temperature, composition, and energy balance.
# Depends on geophysics for surface temperature and planetary parameters.
# =============================================================================

# =============================================================================
# Atmosphere Constants
# =============================================================================

const {
    # Clausius-Clapeyron constants
    atmosphere.e0_pa: 611.0                    # Reference saturation vapor pressure at T0 (Pa)
    atmosphere.t0_k: 273.15                    # Reference temperature (K)
    atmosphere.lv_j_kg: 2.5e6                  # Latent heat of vaporization (J/kg)
    atmosphere.rv_j_kg_k: 461.0                # Gas constant for water vapor (J/kg/K)
    atmosphere.l_over_r: 5423.86               # Lv/Rv precomputed

    # Stefan-Boltzmann
    atmosphere.sigma: 5.67e-8 <W*m⁻²*K⁻⁴>     # Stefan-Boltzmann constant

    # Earth reference values
    atmosphere.earth_surface_temp: 288.0       # Earth mean surface temp (K)
    atmosphere.earth_toa_flux: 1361.0          # Solar constant at Earth (W/m²)
    atmosphere.earth_albedo: 0.3               # Earth's average albedo
    atmosphere.earth_emissivity: 0.95          # Surface emissivity

    # Greenhouse effect
    atmosphere.earth_tau_greenhouse: 1.0       # Earth's optical depth for greenhouse
    atmosphere.co2_ref_ppmv: 280.0             # Pre-industrial CO2 (ppmv)

    # Heat transport
    atmosphere.heat_transport_efficiency: 1e14  # Earth W/K meridional transport
    atmosphere.insolation_ratio: 2.5           # Equator/pole insolation ratio
}

# =============================================================================
# Atmosphere Configuration
# =============================================================================

config {
    /// Radiative balance
    atmosphere.initial_surface_temp: 288.0
    atmosphere.heat_capacity_j_k: 5e23
    atmosphere.emissivity: 0.95
    atmosphere.albedo: 0.3

    # Greenhouse effect
    atmosphere.co2_ppmv: 280.0
    atmosphere.tau_greenhouse: 1.0

    # Water vapor feedback
    atmosphere.water_vapor_enabled: 1.0
    atmosphere.relative_humidity: 0.6
    atmosphere.scale_height_m: 2000.0
    atmosphere.relaxation_time_s: 86400.0
    atmosphere.min_water_vapor_kg_m2: 0.1
    atmosphere.max_water_vapor_kg_m2: 200.0

    # Heat transport
    atmosphere.enable_heat_transport: 1.0
    atmosphere.transport_efficiency_w_k: 1e14
    atmosphere.insolation_ratio: 2.5

    # Initial values
    atmosphere.initial_external_power: 0.0
    atmosphere.initial_water_vapor: 25.0
    atmosphere.initial_co2_ppmv: 280.0
    atmosphere.initial_cloud_cover: 0.5
}

# =============================================================================
# Atmosphere Functions
# =============================================================================

/// Tetens formula for saturation vapor pressure
/// Returns pressure in Pa
fn atmosphere.saturation_vapor_pressure(temperature_k) {
    # e_sat(T) = 610.94 Pa * exp((17.625 * T_C) / (T_C + 243.04))
    # The Tetens formula coefficients are empirical and dimensionless
    # T_C is temperature in Celsius (but we keep K internally for unit safety)
    # To make this work with units, we normalize temperature to dimensionless
    let t_ref = 273.15 <K> in
    let t_scale = 243.04 <K> in
    let t_normalized = (temperature_k - t_ref) / t_scale in  # dimensionless
    let exponent = 17.625 * t_normalized / (1.0 + t_normalized) in  # dimensionless
    610.94 <Pa> * maths.exp(exponent)
}

/// Equilibrium water vapor column mass
fn atmosphere.equilibrium_water_vapor(surface_temp_k, relative_humidity, scale_height_m) {
    : uses(maths.clamping)
    let e_sat = atmosphere.saturation_vapor_pressure(surface_temp_k) in
    let rh = maths.clamp(relative_humidity, 0.0, 1.0) in
    # Gas constant for water vapor Rv = 461 J/(kg·K)
    let rv = 461.0 <J*kg⁻¹*K⁻¹> in
    (e_sat * rh * scale_height_m) / (rv * surface_temp_k)
}

# Effective greenhouse emissivity
fn atmosphere.effective_emissivity(base_emissivity, tau_greenhouse) {
    base_emissivity / (1.0 + 0.75 * tau_greenhouse)
}

# =============================================================================
# External Radiative Forcing
# =============================================================================

signal atmosphere.external_power {
    : Scalar<W, 0..1e20>
    : stratum(atmosphere)
    : initial(1.22e17)
    : title("External Radiative Power")
    : symbol("P_ext")

    config {
        # Default absorbed solar power for Earth: S*(1-α)/4 * 4πR²
        # = 1361 * 0.7 / 4 * 5.1e14 ≈ 1.2e17 W
        default_power: 1.22e17
    }

    resolve {
        # Ephemeral signal - sum of all external radiative inputs
        # On first tick before fractures emit, use default Earth-like value
        if inputs > 0.0 { inputs } else { config.atmosphere.external_power.default_power }
    }

    assert {
        prev >= 0.0 : warn, "External power should be non-negative"
    }
}

# =============================================================================
# Surface Temperature (Three-zone model)
# =============================================================================

# Mean surface temperature
signal atmosphere.surface_temp {
    : Vec3<K>
    : stratum(atmosphere)
    : title("Surface Temperature")
    : symbol("T_surf")

    config {
        emissivity: 0.95
        tau_greenhouse: 1.0
        # Thermal relaxation timescale for planetary temperature
        # ~1000 years for atmospheric thermal inertia at geological scales
        relaxation_tau_s: 3.15e10
        # Initial temperature (Earth mean)
        initial_temp: 288.0
    }

    # Initial value: Earth-like temperatures [mean, equator, pole]
    initial {
        # Simple test: use literal values for now
        vector.vec3(288.0, 308.0, 248.0)
    }

    resolve {
        # T = [T_mean, T_equator, T_pole]
        # At geological timescales (dt >> thermal timescale), temperature equilibrates
        # to radiative balance: P_in = P_out => T_eq = (P_in / (epsilon * sigma * A))^0.25
        #
        # Using relaxation dynamics instead of integration for numerical stability
        # with large dt (10 Myr).

        let epsilon_eff = atmosphere.effective_emissivity(config.atmosphere.surface_temp.emissivity, config.atmosphere.surface_temp.tau_greenhouse) in
        
        # Equilibrium temperature from Stefan-Boltzmann law
        # P_in = epsilon * sigma * A * T^4
        # T_eq = (P_in / (epsilon * sigma * A))^0.25
        # For Earth: A = 5.1e14 m²
        let surface_area = 5.1e14 <m²> in
        let power_in = atmosphere.external_power in
        let t_eq_fourth = power_in / (epsilon_eff * const.atmosphere.sigma * surface_area) in
        # T_eq = t_eq_fourth^0.25 = sqrt(sqrt(t_eq_fourth))
        let t_eq = maths.sqrt(maths.sqrt(t_eq_fourth)) in

        # Relax toward equilibrium temperature
        let t_mean = dt.relax(prev.x, t_eq, config.atmosphere.surface_temp.relaxation_tau_s) in

        # Equator/pole differential: simple linear model from mean
        # T_equator ≈ T_mean + 20K, T_pole ≈ T_mean - 40K (Earth average)
        let t_equator = t_mean + 20.0 in
        let t_pole = t_mean - 40.0 in

        vector.vec3(t_mean, t_equator, t_pole)
    }

    assert {
        prev.x >= 50.0 : warn, "Mean temperature below minimum"
        prev.x <= 500.0 : warn, "Mean temperature above maximum"
    }
}

# =============================================================================
# Water Vapor Feedback (Clausius-Clapeyron)
# =============================================================================

signal atmosphere.water_vapor {
    : Scalar<kg/m², 0.1..200>
    : stratum(atmosphere)
    : uses(maths.clamping)
    : title("Water Vapor Column")
    : symbol("W_v")

    config {
        relative_humidity: 0.6
        scale_height_m: 2000.0 <m>
        relaxation_time_s: 86400.0 <s>
        min: 0.1 <kg/m²>
        max: 200.0 <kg/m²>
    }

    resolve {
        # Water vapor relaxes toward equilibrium determined by surface temperature
        let t_surf = atmosphere.surface_temp.x in
        let equilibrium = atmosphere.equilibrium_water_vapor(t_surf, config.atmosphere.water_vapor.relative_humidity, config.atmosphere.water_vapor.scale_height_m) in

        dt.relax_to(prev, equilibrium, config.atmosphere.water_vapor.relaxation_time_s)
    }

    assert {
        prev >= config.atmosphere.water_vapor.min : warn, "Water vapor below minimum"
        prev <= config.atmosphere.water_vapor.max : warn, "Water vapor above maximum"
    }
}

# =============================================================================
# Atmospheric Composition
# =============================================================================

signal atmosphere.co2_ppmv {
    : Scalar<ppmv, 100..10000>
    : stratum(atmosphere)
    : uses(maths.clamping)
    : initial(280.0)
    : title("CO2 Concentration")
    : symbol("CO2")

    config {
        min: 10.0
        max: 10000.0
        # Relaxation timescale for CO2 equilibration (~100 kyr for silicate weathering feedback)
        relaxation_tau_s: 3.1536e12   # 100,000 years in seconds
    }

    resolve {
        # CO2 equilibrates through volcanic sources, weathering sinks, ocean exchange
        # For geological timescales (dt >> tau), use relaxation toward equilibrium
        # inputs contains equilibrium CO2 targets from fractures
        # If no fractures emit, maintain previous value
        let equilibrium = if inputs > 0.0 { inputs } else { prev } in
        let relaxed = dt.relax(prev, equilibrium, config.atmosphere.co2_ppmv.relaxation_tau_s) in
        maths.clamp(relaxed, config.atmosphere.co2_ppmv.min, config.atmosphere.co2_ppmv.max)
    }

    assert {
        prev >= config.atmosphere.co2_ppmv.min : fatal, "CO2 concentration cannot be negative"
        prev <= config.atmosphere.co2_ppmv.max : error, "CO2 concentration exceeds expected maximum - check sources"
    }
}

# Methane concentration in atmosphere
# Important greenhouse gas with ~12 year lifetime in modern atmosphere
# At geological timescales, CH4 equilibrates rapidly
signal atmosphere.ch4_ppmv {
    : Scalar<ppmv, 0..50>
    : stratum(atmosphere)
    : uses(maths.clamping)
    : initial(1.8)
    : title("CH4 Concentration")
    : symbol("CH4")

    config {
        min: 0.01
        max: 50.0
        # CH4 has short lifetime (~12 yr), equilibrates fast on geological timescales
        relaxation_tau_s: 3.784e8   # ~12 years in seconds
    }

    resolve {
        # Methane equilibrates rapidly due to short atmospheric lifetime
        # For geological timescales, it's essentially at equilibrium each tick
        # inputs contains equilibrium CH4 from biogenic/volcanic sources
        let equilibrium = if inputs > 0.0 { inputs } else { prev } in
        let relaxed = dt.relax(prev, equilibrium, config.atmosphere.ch4_ppmv.relaxation_tau_s) in
        maths.clamp(relaxed, config.atmosphere.ch4_ppmv.min, config.atmosphere.ch4_ppmv.max)
    }

    assert {
        prev >= config.atmosphere.ch4_ppmv.min : fatal, "CH4 concentration cannot be negative"
        prev <= config.atmosphere.ch4_ppmv.max : error, "CH4 concentration exceeds expected maximum - check sources"
    }
}

# =============================================================================
# Cloud Cover
# =============================================================================

signal atmosphere.cloud_cover {
    : Scalar<1, 0..1>
    : stratum(atmosphere)
    : uses(maths.clamping)
    : initial(0.5)
    : title("Cloud Cover Fraction")
    : symbol("C")

    config {
        min_water_vapor: 5.0
        saturation_water_vapor: 50.0
    }

    resolve {
        # Cloud cover depends on water vapor availability
        # Physical constraint: fraction must be [0, 1]
        let water_vapor = atmosphere.water_vapor in
        let cloud_potential = (water_vapor - config.atmosphere.cloud_cover.min_water_vapor) /
                             (config.atmosphere.cloud_cover.saturation_water_vapor - config.atmosphere.cloud_cover.min_water_vapor) in
        maths.clamp(cloud_potential + inputs, 0.0, 1.0)
    }

    assert {
        prev >= 0.0 : fatal, "Cloud cover cannot be negative"
        prev <= 1.0 : fatal, "Cloud cover cannot exceed 1"
    }
}

# =============================================================================
# Atmospheric Optical Depth (Greenhouse)
# =============================================================================

signal atmosphere.tau_greenhouse {
    : Scalar<1, 0..10>
    : stratum(atmosphere)
    : title("Greenhouse Optical Depth")
    : symbol("tau")

    config {
        base_tau: 1.0
        co2_sensitivity: 0.002          # per ppmv (dimensionless)
        water_vapor_sensitivity: 0.01 <m²/kg>  # tau per kg/m² water vapor
    }

    resolve {
        # Optical depth from CO2 and water vapor
        let co2_contribution = (atmosphere.co2_ppmv - const.atmosphere.co2_ref_ppmv) * config.atmosphere.tau_greenhouse.co2_sensitivity in
        let wv_contribution = atmosphere.water_vapor * config.atmosphere.tau_greenhouse.water_vapor_sensitivity in

        config.atmosphere.tau_greenhouse.base_tau + co2_contribution + wv_contribution + inputs
    }

    assert {
        prev >= 0.0 : warn, "Optical depth cannot be negative"
        prev <= 10.0 : warn, "Optical depth exceeds maximum"
    }
}

# =============================================================================
# Atmospheric Pressure
# =============================================================================

signal atmosphere.pressure {
    : Scalar<Pa, 0..1e8>
    : stratum(atmosphere)
    : title("Surface Atmospheric Pressure")
    : symbol("P_surf")

    config {
        total_mass_kg: 5.15e18 <kg>       # Earth atmospheric mass
        reference_pressure_pa: 101325.0 <Pa>  # Earth surface pressure
        reference_mass_kg: 5.15e18 <kg>   # Reference mass for ratio calculation
    }

    resolve {
        # P = (M_atm * g) / (4 * π * R²)
        # Simplified: use configured initial pressure with mass ratio
        let mass_ratio = config.atmosphere.pressure.total_mass_kg / config.atmosphere.pressure.reference_mass_kg in
        config.atmosphere.pressure.reference_pressure_pa * mass_ratio + inputs
    }

    assert {
        prev >= 0.0 : warn, "Pressure cannot be negative"
    }
}

# =============================================================================
# Ice-Albedo Feedback
# =============================================================================

# Ice/snow fraction of planetary surface
signal atmosphere.ice_fraction {
    : Scalar<1, 0..1>
    : stratum(atmosphere)
    : uses(maths.clamping)
    : title("Ice Fraction")
    : symbol("f_ice")

    config {
        # Ice forms below freezing (273.15 K)
        freezing_temp_k: 273.15 <K>
        # Ice edge transition width (K) - smooth transition zone
        transition_width_k: 10.0 <K>
        # Relaxation timescale for ice dynamics (s) - ~1 year
        relaxation_tau_s: 3.1536e7 <s>
    }

    resolve {
        # Ice fraction calculated from pole temperature
        # Using smooth transition around freezing point
        let t_pole = atmosphere.surface_temp.z in
        let t_equator = atmosphere.surface_temp.y in

        # Calculate ice edge latitude based on linear temperature gradient
        # Ice exists where T < freezing temperature
        let t_freeze = config.atmosphere.ice_fraction.freezing_temp_k in

        if t_equator < t_freeze {
            # Snowball Earth: complete ice coverage
            1.0
        } else if t_pole >= t_freeze {
            # Ice-free: no ice coverage
            0.0
        } else {
            # Partial ice: linear interpolation
            # Ice edge at latitude where T = t_freeze
            # Approximate: ice_fraction ≈ (t_freeze - t_pole) / (t_equator - t_pole)
            # Physical constraint: fraction must be [0, 1]
            let temp_range = maths.max(t_equator - t_pole, 1.0 <K>) in
            let ice_extent = (t_freeze - t_pole) / temp_range in
            maths.clamp(ice_extent, 0.0, 1.0)
        }
    }

    assert {
        prev >= 0.0 : fatal, "Ice fraction cannot be negative"
        prev <= 1.0 : fatal, "Ice fraction cannot exceed 1"
    }
}

# Effective planetary albedo with ice-albedo feedback
signal atmosphere.albedo {
    : Scalar<1, 0..1>
    : stratum(atmosphere)
    : uses(maths.clamping)
    : title("Effective Planetary Albedo")
    : symbol("α")

    config {
        # Base surface albedo (land/ocean mix)
        base_surface_albedo: 0.12
        # Ice/snow albedo (high reflectivity)
        ice_albedo: 0.80
        # Cloud albedo
        cloud_albedo: 0.50
    }

    resolve {
        # Surface albedo: blend of base and ice based on ice fraction
        let ice_frac = atmosphere.ice_fraction in
        let surface_albedo = config.atmosphere.albedo.base_surface_albedo * (1.0 - ice_frac)
                           + config.atmosphere.albedo.ice_albedo * ice_frac in

        # Add cloud contribution
        # Model: fraction of sunlight reflected by clouds + rest hits surface
        let cloud_frac = atmosphere.cloud_cover in
        let clear_frac = 1.0 - cloud_frac in
        let planetary_albedo = cloud_frac * config.atmosphere.albedo.cloud_albedo
                             + clear_frac * surface_albedo in

        # Physical constraint: reflectivity must be [0, 1]
        maths.clamp(planetary_albedo + inputs, 0.0, 1.0)
    }

    assert {
        prev >= 0.0 : fatal, "Albedo cannot be negative"
        prev <= 1.0 : fatal, "Albedo cannot exceed 1"
    }
}

# =============================================================================
# Solar Insolation (from stellar domain coupling)
# =============================================================================

signal atmosphere.solar_constant {
    : Scalar<W/m², 0..1e5>
    : stratum(atmosphere)
    : title("Solar Constant")
    : symbol("S")

    config {
        # Earth's top-of-atmosphere solar flux
        reference_flux: 1361.0
    }

    resolve {
        # Ephemeral signal - receives flux from stellar domain coupling
        # Default to reference value if no external input
        if inputs > 0.0 { inputs } else { config.atmosphere.solar_constant.reference_flux }
    }

    assert {
        prev >= 0.0 : warn, "Solar constant cannot be negative"
    }
}

# Absorbed solar radiation (after albedo reflection)
signal atmosphere.absorbed_radiation {
    : Scalar<W/m², 0..1e5>
    : stratum(atmosphere)
    : title("Absorbed Solar Radiation")
    : symbol("Q_abs")

    resolve {
        # Q_abs = S * (1 - α) / 4
        # Factor of 4: sphere receives radiation on disk area (πR²) but radiates from full surface (4πR²)
        let solar = atmosphere.solar_constant in
        let albedo = atmosphere.albedo in
        solar * (1.0 - albedo) / 4.0 + inputs
    }

    assert {
        prev >= 0.0 : warn, "Absorbed radiation cannot be negative"
    }
}

# =============================================================================
# Cross-Domain Coupling Fractures
# =============================================================================

# -----------------------------------------------------------------------------
# Stellar → Atmosphere Coupling
# -----------------------------------------------------------------------------

# Stellar insolation coupling: transfers stellar flux to atmosphere
# This fracture connects the stellar domain's computed insolation to the
# atmosphere's radiative budget, enabling star variability, orbital changes,
# and binary/trinary star systems to affect planetary climate.
fracture atmosphere.stellar_insolation_coupling {
    : stratum(atmosphere)

    config {
        # Planet cross-section to surface area ratio (1/4 for sphere)
        geometric_factor: 0.25
    }

    when {
        # Always active when stellar domain provides insolation
        stellar.total_insolation > 0.0
    }

    collect {
        # Transfer stellar flux to atmosphere solar constant
        # This replaces the default reference value with actual stellar input
        let flux = stellar.total_insolation
        atmosphere.solar_constant <- flux

        # Calculate absorbed power accounting for albedo
        # P_absorbed = S * (1 - α) * π * R² (disk area)
        # = S * (1 - α) / 4 * 4 * π * R² (full surface)
        let albedo = atmosphere.albedo
        let absorbed_flux = flux * (1.0 - albedo) * config.atmosphere.stellar_insolation_coupling.geometric_factor

        # Convert to total power: P = F * A = F * 4πR²
        let planet_radius = planet.radius
        let surface_area = 4.0 * PI * planet_radius * planet_radius
        let absorbed_power = absorbed_flux * surface_area

        atmosphere.external_power <- absorbed_power
    }
}

# =============================================================================
# Atmosphere Fractures
# =============================================================================

# Runaway greenhouse threshold
fracture atmosphere.runaway_greenhouse {
    : stratum(atmosphere)

    when {
        atmosphere.surface_temp.x > 350.0 <K>
        atmosphere.water_vapor > 150.0
    }

    collect {
        atmosphere.water_vapor <- 50.0
        atmosphere.co2_ppmv <- 100.0
    }
}

# Ice age trigger
fracture atmosphere.ice_age {
    : stratum(atmosphere)

    when {
        atmosphere.surface_temp.x < 270.0 <K>
        atmosphere.co2_ppmv < 200.0
    }

    collect {
        # Reduced weathering allows CO2 buildup
        atmosphere.co2_ppmv <- 50.0
    }
}

# -----------------------------------------------------------------------------
# Cross-Domain Carbon Cycle Fractures
# -----------------------------------------------------------------------------

# CO2 equilibrium dynamics: volcanic sources vs weathering/ocean sinks
# At geological timescales, CO2 equilibrates to balance sources and sinks
# This single fracture computes the equilibrium including all feedbacks
fracture atmosphere.co2_equilibrium {
    : stratum(atmosphere)
    : uses(maths.clamping)

    config {
        # Base equilibrium CO2 at Earth-like conditions (activity = 1.0, temp = 288K)
        base_equilibrium_ppmv: 280.0
        # Volcanic/tectonic activity scaling
        activity_exponent: 0.5
        # Minimum equilibrium (dormant tectonics)
        min_equilibrium_ppmv: 50.0
        # Temperature sensitivity (silicate weathering thermostat)
        # Weathering efficiency doubles every 10K above reference
        weathering_sensitivity: 0.0693 <K⁻¹>  # ln(2)/10 per K
        # Ocean solubility: CO2 capacity decreases ~3% per K warming
        ocean_sensitivity: 0.03 <K⁻¹>
        # Reference temperature for feedbacks
        reference_temp_k: 288.0 <K>
    }

    when {
        tectonics.activity > 0.0
    }

    collect {
        let activity = maths.max(tectonics.activity, 0.1)
        let temp = atmosphere.surface_temp.x
        let ref_temp = config.atmosphere.co2_equilibrium.reference_temp_k
        let temp_anomaly = temp - ref_temp

        # 1. Base equilibrium from volcanic activity
        let activity_factor = maths.pow(activity, config.atmosphere.co2_equilibrium.activity_exponent)
        let volcanic_equilibrium = maths.max(
            config.atmosphere.co2_equilibrium.base_equilibrium_ppmv * activity_factor,
            config.atmosphere.co2_equilibrium.min_equilibrium_ppmv
        )

        # 2. Silicate weathering feedback (thermostat)
        # Warmer -> more weathering -> lower equilibrium
        let weathering_factor = maths.exp(-config.atmosphere.co2_equilibrium.weathering_sensitivity * temp_anomaly)

        # 3. Ocean solubility feedback
        # Warmer -> less ocean capacity -> higher equilibrium
        let ocean_factor = 1.0 + temp_anomaly * config.atmosphere.co2_equilibrium.ocean_sensitivity

        # Combined equilibrium with feedbacks
        # Note: weathering and ocean feedbacks partially cancel
        let equilibrium_ppmv = volcanic_equilibrium * weathering_factor * ocean_factor

        atmosphere.co2_ppmv <- maths.clamp(equilibrium_ppmv, 50.0, 5000.0)
    }
}

# Methane equilibrium from volcanic/hydrothermal sources
# CH4 has short atmospheric lifetime (~12 yr), equilibrates rapidly on geological timescales
fracture atmosphere.ch4_equilibrium {
    : stratum(atmosphere)

    config {
        # Base equilibrium CH4 at Earth-like conditions
        base_equilibrium_ppmv: 1.8
        # Volcanic/tectonic activity scaling
        activity_sensitivity: 0.3
        # Minimum equilibrium (always some abiotic sources)
        min_equilibrium_ppmv: 0.1
    }

    when {
        tectonics.activity > 0.0
    }

    collect {
        # Methane equilibrium depends on volcanic/hydrothermal activity
        let activity = tectonics.activity
        let equilibrium_ppmv = maths.max(
            config.atmosphere.ch4_equilibrium.base_equilibrium_ppmv * 
            (1.0 + config.atmosphere.ch4_equilibrium.activity_sensitivity * (activity - 1.0)),
            config.atmosphere.ch4_equilibrium.min_equilibrium_ppmv
        )

        atmosphere.ch4_ppmv <- equilibrium_ppmv
    }
}

# =============================================================================
# Atmosphere Fields
# =============================================================================

field atmosphere.temperature {
    : Scalar<K>
    : stratum(atmosphere)
    : topology(point_cloud)
    : title("Surface Temperature Field")

    measure {
        atmosphere.surface_temp.x
    }
}

field atmosphere.water_vapor_map {
    : Scalar<kg/m²>
    : stratum(atmosphere)
    : topology(point_cloud)
    : title("Water Vapor Column Field")

    measure {
        atmosphere.water_vapor
    }
}

field atmosphere.cloud_map {
    : Scalar<1>
    : stratum(atmosphere)
    : topology(point_cloud)
    : title("Cloud Cover Field")

    measure {
        atmosphere.cloud_cover
    }
}

field atmosphere.co2_map {
    : Scalar<ppmv>
    : stratum(atmosphere)
    : topology(point_cloud)
    : title("CO2 Concentration Field")

    measure {
        atmosphere.co2_ppmv
    }
}

field atmosphere.pressure_map {
    : Scalar<Pa>
    : stratum(atmosphere)
    : topology(point_cloud)
    : title("Surface Pressure Field")

    measure {
        atmosphere.pressure
    }
}

field atmosphere.ice_fraction_map {
    : Scalar<1>
    : stratum(atmosphere)
    : topology(sphere_surface)
    : title("Ice Fraction Field")

    measure {
        atmosphere.ice_fraction
    }
}

field atmosphere.albedo_map {
    : Scalar<1>
    : stratum(atmosphere)
    : topology(sphere_surface)
    : title("Effective Albedo Field")

    measure {
        atmosphere.albedo
    }
}

field atmosphere.solar_constant_map {
    : Scalar<W/m²>
    : stratum(atmosphere)
    : topology(point_cloud)
    : title("Solar Constant Field")

    measure {
        atmosphere.solar_constant
    }
}

field atmosphere.absorbed_radiation_map {
    : Scalar<W/m²>
    : stratum(atmosphere)
    : topology(sphere_surface)
    : title("Absorbed Radiation Field")

    measure {
        atmosphere.absorbed_radiation
    }
}

field atmosphere.greenhouse_map {
    : Scalar<1>
    : stratum(atmosphere)
    : topology(point_cloud)
    : title("Greenhouse Optical Depth Field")

    measure {
        atmosphere.tau_greenhouse
    }
}

# =============================================================================
# Atmosphere Chronicles
# =============================================================================

# Snowball Earth event: global glaciation
chronicle atmosphere.events.snowball_earth {
    : stratum(atmosphere)

    observe {
        when atmosphere.ice_fraction > 0.9 {
            emit event.snowball_earth {
                ice_fraction: atmosphere.ice_fraction
                surface_temp: atmosphere.surface_temp.x
                co2_ppmv: atmosphere.co2_ppmv
                albedo: atmosphere.albedo
                severity: "critical"
                description: "Global glaciation - snowball Earth conditions"
            }
        }
    }
}

# Runaway greenhouse event: Venus-like conditions
chronicle atmosphere.events.runaway_greenhouse {
    : stratum(atmosphere)

    observe {
        when atmosphere.surface_temp.x > 350.0 <K> {
            emit event.runaway_greenhouse {
                surface_temp: atmosphere.surface_temp.x
                water_vapor: atmosphere.water_vapor
                co2_ppmv: atmosphere.co2_ppmv
                greenhouse_depth: atmosphere.tau_greenhouse
                severity: "critical"
                description: "Runaway greenhouse - Venus-like atmospheric conditions"
            }
        }
    }
}

# Oxygenation event: significant O2 buildup (when O2 tracking is enabled)
# Currently placeholder since O2 signal not implemented yet
# chronicle atmosphere.events.oxygenation {
#     observe {
#         when atmosphere.o2_ppmv > 1000.0 {
#             emit event.oxygenation {
#                 o2_ppmv: atmosphere.o2_ppmv
#                 co2_ppmv: atmosphere.co2_ppmv
#                 surface_temp: atmosphere.surface_temp.x
#                 severity: "major"
#                 description: "Great oxygenation event - atmospheric O2 buildup"
#             }
#         }
#     }
# }

# Ice age onset: significant cooling and glaciation
chronicle atmosphere.events.ice_age_onset {
    : stratum(atmosphere)

    observe {
        when atmosphere.surface_temp.x < 270.0 <K> and
             atmosphere.ice_fraction > 0.3 {
            emit event.ice_age_onset {
                surface_temp: atmosphere.surface_temp.x
                ice_fraction: atmosphere.ice_fraction
                co2_ppmv: atmosphere.co2_ppmv
                severity: "major"
                description: "Ice age onset - significant glaciation"
            }
        }
    }
}

# Atmospheric collapse: extreme pressure loss
chronicle atmosphere.events.atmospheric_collapse {
    : stratum(atmosphere)

    observe {
        when atmosphere.pressure < 10000.0 {
            emit event.atmospheric_collapse {
                pressure: atmosphere.pressure
                surface_temp: atmosphere.surface_temp.x
                water_vapor: atmosphere.water_vapor
                severity: "critical"
                description: "Atmospheric collapse - extreme pressure loss"
            }
        }
    }
}
