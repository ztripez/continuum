# Stellar Domain
# =============================================================================
# Handles stars and moons as entities with orbital mechanics, radiation output,
# stellar variability, and tidal effects.
#
# Supports:
# - Multiple stars (single, binary, trinary systems)
# - Multiple moons with individual orbital mechanics
# - Stellar variability (starspots, activity cycles, flares)
# - Tidal heating from moons and companion stars
# =============================================================================

# =============================================================================
# Stellar Constants
# =============================================================================

const {
    # Physical constants
    stellar.solar_luminosity_w: 3.828e26          # Sun luminosity (W)
    stellar.solar_mass_kg: 1.989e30               # Sun mass (kg)
    stellar.solar_radius_m: 6.9634e8              # Sun radius (m)
    stellar.solar_teff_k: 5780.0                  # Sun effective temperature (K)
    stellar.au_m: 1.495978707e11                  # Astronomical unit (m)
    stellar.gravitational_constant: 6.67430e-11  # G (mÂ³/kg/sÂ²)

    # Evolution constants
    stellar.main_sequence_evolution_rate: 1e-4   # Luminosity increase per Myr (~1% per 100 Myr)

    # Tidal constants
    stellar.tidal_quality_factor: 100.0          # Q factor for tidal dissipation
    stellar.love_number: 0.3                     # k2 Love number

    # Moon recession
    stellar.lunar_recession_rate: 3.8e-2         # Earth's Moon recession (m/year)
}

# =============================================================================
# Stellar Configuration
# =============================================================================

config {
    # Star defaults
    stellar.default_luminosity: 3.828e26         # W (solar)
    stellar.default_star_mass: 1.989e30          # kg (solar)
    stellar.default_star_radius: 6.9634e8        # m (solar)
    stellar.default_teff: 5780.0                 # K (solar)

    # Moon defaults
    stellar.default_moon_mass: 7.342e22          # kg (Luna)
    stellar.default_moon_radius: 1.737e6         # m (Luna)

    # Orbit defaults
    stellar.default_planet_orbit_radius: 1.495978707e11  # m (1 AU)
    stellar.default_moon_orbit_radius: 3.844e8           # m (Luna)

    # Variability defaults (quiet star)
    stellar.default_rotation_period_days: 25.0
    stellar.default_spot_amplitude: 0.001
    stellar.default_activity_cycle_years: 11.0
    stellar.default_flare_rate_per_day: 0.0
    stellar.default_variability_factor: 1.0

    # Counts (overridden by scenario)
    stellar.star_count: 1
    stellar.moon_count: 1
}

# =============================================================================
# Stellar Strata
# =============================================================================

strata.stellar.orbit {
    : title("Stellar Orbit")
    : symbol("SO")
    : stride(1)
}

strata.stellar.activity {
    : title("Stellar Activity")
    : symbol("SA")
    : stride(100)
}

strata.stellar.tides {
    : title("Stellar Tides")
    : symbol("ST")
    : stride(1)
}

# =============================================================================
# Star Entity
# =============================================================================

entity.stellar.star {
    : count(config.stellar.star_count)
    : count_bounds(1, 4)

    signal mass {
        : Scalar<kg, 1e28..1e32>
        : stratum(orbit)
        : title("Star Mass")
        : symbol("M_star")
    
        initial { config.stellar.default_star_mass }
        resolve { prev }
    }

    signal radius {
        : Scalar<m, 1e8..1e10>
        : stratum(orbit)
        : title("Star Radius")
        : symbol("R_star")
    
        initial { config.stellar.default_star_radius }
        resolve { prev }
    }

    signal luminosity_base {
        : Scalar<W, 1e24..1e30>
        : stratum(orbit)
        : title("Base Luminosity")
        : symbol("L_base")
    
        initial { config.stellar.default_luminosity }
        resolve { prev }
    }

    signal teff {
        : Scalar<K, 2000..50000>
        : stratum(orbit)
        : title("Effective Temperature")
        : symbol("T_eff")
    
        initial { config.stellar.default_teff }
        resolve { prev }
    }

    signal luminosity_evolution_rate {
        : Scalar<1/Myr, 0..1e-3>
        : stratum(orbit)
        : title("Luminosity Evolution Rate")
        : symbol("dL/dt")
    
        initial { const.stellar.main_sequence_evolution_rate }
        resolve { prev }
    }

    signal orbit_radius {
        : Scalar<m, 0..1e14>
        : stratum(orbit)
        : title("Orbit Semi-major Axis")
        : symbol("a_star")
    
        initial { 0.0 }
        resolve { prev }
    }

    signal orbit_eccentricity {
        : Scalar<1, 0..0.99>
        : stratum(orbit)
        : title("Orbit Eccentricity")
        : symbol("e_star")
    
        initial { 0.0 }
        resolve { prev }
    }

    signal orbit_phase {
        : Scalar<rad, 0..TAU>
        : stratum(orbit)
        : title("Orbit Phase")
        : symbol("phi_star")
        : uses(dt.raw)
    
        resolve {
            # Advance phase based on orbital period
            let mu = const.stellar.gravitational_constant * self.mass in
            let period = TAU * maths.sqrt(maths.pow(self.orbit_radius, 3) / mu) in
            let omega = TAU / maths.max(period, 1.0) in
            maths.wrap(prev + omega * dt.raw, 0.0, TAU)
        }
    }

    signal orbit_inclination {
        : Scalar<rad, 0..PI>
        : stratum(orbit)
        : title("Orbit Inclination")
        : symbol("i_star")
    
        initial { 0.0 }
        resolve { prev }
    }

    signal position {
        : Vec3<m>
        : stratum(orbit)
        : title("Star Position")
        : symbol("r_star")
    
        resolve {
            # Compute position from Keplerian elements
            let r = self.orbit_radius * (1.0 - self.orbit_eccentricity * maths.cos(self.orbit_phase)) in
            let x = r * maths.cos(self.orbit_phase) in
            let y = r * maths.sin(self.orbit_phase) * maths.cos(self.orbit_inclination) in
            let z = r * maths.sin(self.orbit_phase) * maths.sin(self.orbit_inclination) in
            vector.vec3(x, y, z)
        }
    }

    signal direction {
        : Vec3
        : stratum(orbit)
        : title("Star Direction from Planet")
        : symbol("d_star")
    
        resolve {
            vector.normalize(self.position)
        }
    }

    signal distance {
        : Scalar<m, 0..1e15>
        : stratum(orbit)
        : title("Distance to Star")
        : symbol("r_star")
    
        resolve {
            vector.length(self.position)
        }
    }

    signal rotation_period {
        : Scalar<day, 0.1..100>
        : stratum(activity)
        : title("Rotation Period")
        : symbol("P_rot")
    
        initial { config.stellar.default_rotation_period_days }
        resolve { prev }
    }

    signal spot_amplitude {
        : Scalar<1, 0..0.1>
        : stratum(activity)
        : title("Starspot Amplitude")
        : symbol("A_spot")
    
        initial { config.stellar.default_spot_amplitude }
        resolve { prev }
    }

    signal activity_cycle_period {
        : Scalar<yr, 1..100>
        : stratum(activity)
        : title("Activity Cycle Period")
        : symbol("P_cycle")
    
        initial { config.stellar.default_activity_cycle_years }
        resolve { prev }
    }

    signal flare_rate {
        : Scalar<1/day, 0..10>
        : stratum(activity)
        : title("Flare Rate")
        : symbol("R_flare")
    
        initial { config.stellar.default_flare_rate_per_day }
        resolve { prev }
    }

    signal variability_factor {
        : Scalar<1, 0.5..2.0>
        : stratum(orbit)  # Must be in orbit stratum so it's computed before luminosity
        : title("Luminosity Variability Factor")
        : symbol("f_var")
    
        initial { config.stellar.default_variability_factor }
    
        resolve {
            # Rotational modulation (starspots)
            # At geological timescales this averages out, but we keep it for completeness
            let rot_phase = sim.time / (self.rotation_period * 86400.0) in
            let spot_mod = 1.0 - self.spot_amplitude * maths.sin(TAU * rot_phase) in
    
            # Activity cycle modulation
            let cycle_phase = sim.time / (self.activity_cycle_period * 3.1536e7) in
            let cycle_mod = 1.0 - self.spot_amplitude * 0.5 * maths.sin(TAU * cycle_phase) in
    
            spot_mod * cycle_mod
        }
    }

    signal luminosity {
        : Scalar<W, 1e24..1e30>
        : stratum(orbit)
        : title("Current Luminosity")
        : symbol("L_star")
    
        resolve {
            # Main sequence evolution: luminosity increases over time
            let elapsed_myr = sim.time / 3.1536e13 in
            let evolution_factor = 1.0 + elapsed_myr * self.luminosity_evolution_rate in
            self.luminosity_base * evolution_factor * self.variability_factor
        }
    }

    signal angular_radius {
        : Scalar<rad, 0..0.1>
        : stratum(orbit)
        : title("Angular Radius")
        : symbol("theta_star")
    
        resolve {
            maths.atan(self.radius / maths.max(self.distance, 1.0))
        }
    }

    signal flux {
        : Scalar<W/mÂ², 0..1e6>
        : stratum(orbit)
        : title("Stellar Flux at Planet")
        : symbol("F_star")
    
        resolve {
            # For single star at center, use planet orbit distance; for binary stars, use star distance
            let d = maths.max(self.distance, config.stellar.default_planet_orbit_radius) in
            self.luminosity / (4.0 * PI * d * d)
        }
    }

}

# -----------------------------------------------------------------------------
# Star Physical Properties
# -----------------------------------------------------------------------------




# -----------------------------------------------------------------------------
# Star Orbital Elements (for binary/trinary systems)
# -----------------------------------------------------------------------------




# -----------------------------------------------------------------------------
# Star Position (derived from orbital elements)
# -----------------------------------------------------------------------------



# -----------------------------------------------------------------------------
# Star Variability
# -----------------------------------------------------------------------------




# -----------------------------------------------------------------------------
# Star Variability Factor (combined effect)
# -----------------------------------------------------------------------------


# -----------------------------------------------------------------------------
# Star Evolved Luminosity
# -----------------------------------------------------------------------------


# -----------------------------------------------------------------------------
# Star Angular Radius (for eclipse calculations)
# -----------------------------------------------------------------------------


# -----------------------------------------------------------------------------
# Star Flux at Planet
# -----------------------------------------------------------------------------


# =============================================================================
# Moon Entity
# =============================================================================

entity.stellar.moon {
    : count(config.stellar.moon_count)
    : count_bounds(0, 20)

    signal mass {
        : Scalar<kg, 1e15..1e24>
        : stratum(orbit)
        : title("Moon Mass")
        : symbol("M_moon")
    
        initial { config.stellar.default_moon_mass }
        resolve { prev }
    }

    signal radius {
        : Scalar<m, 1e3..1e7>
        : stratum(orbit)
        : title("Moon Radius")
        : symbol("R_moon")
    
        initial { config.stellar.default_moon_radius }
        resolve { prev }
    }

    signal orbit_radius {
        : Scalar<m, 1e6..1e10>
        : stratum(orbit)
        : title("Orbit Semi-major Axis")
        : symbol("a_moon")
    
        initial { config.stellar.default_moon_orbit_radius }
        resolve {
            # Apply tidal recession if configured
            prev + self.tidal_recession_rate
        }
    }

    signal orbit_eccentricity {
        : Scalar<1, 0..0.5>
        : stratum(orbit)
        : title("Orbit Eccentricity")
        : symbol("e_moon")
    
        initial { 0.0549 }
        resolve { prev }
    }

    signal orbit_phase {
        : Scalar<rad, 0..TAU>
        : stratum(orbit)
        : title("Orbit Phase")
        : symbol("phi_moon")
        : uses(dt.raw)
    
        resolve {
            # Kepler's third law for orbital period
            let mu = const.stellar.gravitational_constant * planet.mass in
            let period = TAU * maths.sqrt(maths.pow(self.orbit_radius, 3) / mu) in
            let omega = TAU / maths.max(period, 1.0) in
            maths.wrap(prev + omega * dt.raw, 0.0, TAU)
        }
    }

    signal orbit_inclination {
        : Scalar<rad, 0..PI>
        : stratum(orbit)
        : title("Orbit Inclination")
        : symbol("i_moon")
    
        initial { 0.0898 }
        resolve { prev }
    }

    signal tidal_recession_rate {
        : Scalar<m/s, 0..1e-6>
        : stratum(orbit)
        : title("Tidal Recession Rate")
        : symbol("dr/dt")
    
        initial { 0.0 }
        resolve { prev }
    }

    signal position {
        : Vec3<m>
        : stratum(orbit)
        : title("Moon Position")
        : symbol("r_moon")
    
        resolve {
            let r = self.orbit_radius * (1.0 - self.orbit_eccentricity * maths.cos(self.orbit_phase)) in
            let x = r * maths.cos(self.orbit_phase) in
            let y = r * maths.sin(self.orbit_phase) * maths.cos(self.orbit_inclination) in
            let z = r * maths.sin(self.orbit_phase) * maths.sin(self.orbit_inclination) in
            vector.vec3(x, y, z)
        }
    }

    signal direction {
        : Vec3
        : stratum(orbit)
        : title("Moon Direction from Planet")
        : symbol("d_moon")
    
        resolve {
            vector.normalize(self.position)
        }
    }

    signal distance {
        : Scalar<m, 0..1e10>
        : stratum(orbit)
        : title("Distance to Moon")
        : symbol("r_moon")
    
        resolve {
            vector.length(self.position)
        }
    }

    signal angular_radius {
        : Scalar<rad, 0..0.1>
        : stratum(orbit)
        : title("Angular Radius")
        : symbol("theta_moon")
    
        resolve {
            maths.atan(self.radius / maths.max(self.distance, 1.0))
        }
    }

    signal tidal_force {
        : Scalar<N/kg, 0..1e-5>
        : stratum(tides)
        : title("Tidal Force per Unit Mass")
        : symbol("F_tidal")
    
        resolve {
            # Tidal acceleration = 2 * G * M / rÂ³ * R_planet
            let r3 = maths.pow(self.distance, 3) in
            2.0 * const.stellar.gravitational_constant * self.mass * planet.radius / maths.max(r3, 1.0)
        }
    }

    signal tidal_heating {
        : Scalar<W, 0..1e15>
        : stratum(tides)
        : title("Tidal Heating Power")
        : symbol("P_tidal")
    
        resolve {
            # Simplified tidal heating: P = k * (M_moon/rÂ³)Â² * eÂ² * R^5 * n
            let n = maths.sqrt(const.stellar.gravitational_constant * planet.mass / maths.pow(self.orbit_radius, 3)) in
            let factor = const.stellar.love_number / const.stellar.tidal_quality_factor in
            let r3 = maths.pow(self.distance, 3) in
            let term = self.mass / maths.max(r3, 1.0) in
            factor * term * term * maths.pow(self.orbit_eccentricity, 2) * maths.pow(planet.radius, 5) * n
        }
    }

}

# -----------------------------------------------------------------------------
# Moon Physical Properties
# -----------------------------------------------------------------------------



# -----------------------------------------------------------------------------
# Moon Orbital Elements
# -----------------------------------------------------------------------------




# -----------------------------------------------------------------------------
# Moon Position (derived from orbital elements)
# -----------------------------------------------------------------------------



# -----------------------------------------------------------------------------
# Moon Angular Radius (for eclipse calculations)
# -----------------------------------------------------------------------------


# -----------------------------------------------------------------------------
# Moon Tidal Effect
# -----------------------------------------------------------------------------



# =============================================================================
# Aggregate Signals
# =============================================================================

# Total insolation from all stars
# NOTE: Using constant value as workaround for entity member initialization issue
# TODO: Fix entity member initial value propagation (continuum-wpqp)
signal.stellar.total_insolation {
    : Scalar<W/mÂ², 0..1e6>
    : stratum(orbit)
    : title("Total Stellar Insolation")
    : symbol("F_total")

    config {
        # Solar constant at 1 AU
        solar_constant: 1361.0
    }

    resolve {
        # Temporarily use constant until entity initialization is fixed
        config.stellar.total_insolation.solar_constant
    }
}

# Total tidal heating power from all moons
signal.stellar.total_tidal_power {
    : Scalar<W, 0..1e16>
    : stratum(tides)
    : title("Total Tidal Heating Power")
    : symbol("P_tidal_total")

    resolve {
        agg.sum(entity.stellar.moon, self.tidal_heating)
    }
}

# Total tidal amplitude from all moons
# Used for field visualization - aggregates tidal force contribution
signal.stellar.total_tidal_amplitude {
    : Scalar<m, 0..1e6>
    : stratum(tides)
    : title("Total Tidal Amplitude")
    : symbol("A_tidal_total")

    resolve {
        agg.sum(entity.stellar.moon, self.tidal_force * planet.radius)
    }
}

# Star count
signal.stellar.star_count {
    : Scalar<1, 0..4>
    : stratum(orbit)
    : title("Number of Stars")
    : symbol("N_star")

    resolve {
        agg.count(entity.stellar.star)
    }
}

# Moon count
signal.stellar.moon_count {
    : Scalar<1, 0..20>
    : stratum(orbit)
    : title("Number of Moons")
    : symbol("N_moon")

    resolve {
        agg.count(entity.stellar.moon)
    }
}

# =============================================================================
# Stellar Impulses
# =============================================================================

# -----------------------------------------------------------------------------
# Impact Impulse (Asteroid/Comet)
# -----------------------------------------------------------------------------
# External bolide impact: injects energy into crust/mantle, creates ejecta,
# may modify rotation/orbit. Payload specifies impactor properties and geometry.

type ImpactImpulsePayload {
    impactor_mass: Scalar<kg>          # Mass of impactor (kg)
    velocity: Scalar<m/s>              # Impact velocity (m/s)
    impact_angle: Scalar<rad>          # Impact angle from vertical (rad)
    location_lat: Scalar<rad>          # Impact latitude (rad)
    location_lon: Scalar<rad>          # Impact longitude (rad)
}

/// Asteroid or comet impact event. Deposits kinetic energy into crust and mantle,
/// triggers volcanic activity, deposits ejecta, and can alter planetary rotation
/// for very large impacts. Energy partitioned between thermal heating and mechanical deformation.
impulse.stellar.impact {
    : ImpactImpulsePayload
    : stratum(orbit)
    : title("Impact Impulse")
    : symbol("ðŸ’¥")

    config {
        # Energy partition coefficients
        crust_partition: 0.3              # Fraction of energy to crust heating
        mantle_partition: 0.4             # Fraction of energy to mantle heating
        ejecta_partition: 0.3             # Fraction of energy to ejecta/vapor

        # Ejecta and crater scaling
        crater_scaling_factor: 1.2e-4     # Crater diameter per unit energy^1/3
        ejecta_thickness_factor: 1e-8     # Ejecta thickness scaling

        # Minimum energy for significant effects
        min_significant_energy_j: 1.0e20

        # Rotation change scaling (for very large impacts)
        rotation_coupling_factor: 1e-30   # Angular momentum transfer efficiency
    }

    collect {
        # Compute impact energy: KE = 0.5 * m * vÂ²
        let energy_j = 0.5 * payload.impactor_mass * payload.velocity * payload.velocity

        if energy_j > config.impulse.stellar.impact.min_significant_energy_j {
            # Partition energy into crust, mantle, and ejecta
            let crust_energy = energy_j * config.impulse.stellar.impact.crust_partition
            let mantle_energy = energy_j * config.impulse.stellar.impact.mantle_partition

            # Heat deposition into geophysics thermal budget
            mantle.heat_content <- mantle_energy
            surface.temp <- crust_energy / 1.0e20  # Normalize to temperature increment

            # Crustal thickening from ejecta/melt redistribution
            let ejecta_thickness = maths.pow(energy_j, 0.333) * config.impulse.stellar.impact.ejecta_thickness_factor
            crust.thickness <- ejecta_thickness

            # Large impacts can trigger volcanic activity
            tectonics.volcanism <- energy_j / 1.0e24

            # Very large impacts can alter rotation (angular momentum transfer)
            # Delta_omega ~ (m * v * R_impact) / (I_planet) where I ~ M_planet * RÂ²
            let angular_momentum = payload.impactor_mass * payload.velocity * planet.radius
            let moment_of_inertia = planet.mass * planet.radius * planet.radius
            let delta_omega = angular_momentum / moment_of_inertia * config.impulse.stellar.impact.rotation_coupling_factor
            rotation.state <- vector.vec2(0.0, delta_omega)
        }
    }
}

# -----------------------------------------------------------------------------
# Orbital Change Impulse (Milankovitch Forcing)
# -----------------------------------------------------------------------------
# External perturbation to planetary orbital elements: eccentricity, obliquity, precession.
# Used to model long-term orbital variations (Milankovitch cycles) or sudden events
# (e.g., planetary migration, close encounters).

type OrbitalChangePayload {
    delta_eccentricity: Scalar<1>      # Change in orbital eccentricity (dimensionless)
    delta_obliquity: Scalar<rad>       # Change in axial obliquity (rad)
    delta_precession: Scalar<rad>      # Change in precession angle (rad)
}

/// External perturbation to planetary orbital elements. Models Milankovitch cycles
/// (long-term orbital variations driving climate) or sudden events like planetary migration
/// or close encounters. Changes eccentricity, obliquity, and precession of orbit.
impulse.stellar.orbital_change {
    : OrbitalChangePayload
    : stratum(orbit)
    : title("Orbital Change")
    : symbol("ðŸŒ")

    config {
        # Maximum allowed changes per impulse (safety bounds)
        max_delta_eccentricity: 0.05
        max_delta_obliquity: 0.1          # ~5.7 degrees
        max_delta_precession: 0.5         # ~28.6 degrees

        # Minimum changes for significant climate effects
        min_significant_eccentricity: 0.001
        min_significant_obliquity: 0.01   # ~0.57 degrees
        min_significant_precession: 0.05  # ~2.9 degrees
    }

    collect {
        # Clamp external impulse inputs to safety bounds to prevent simulation instability.
        # These are external inputs (not internal simulation state), so clamping is legitimate
        # to protect the simulation from bad external data.
        let clamped_de = maths.clamp(
            payload.delta_eccentricity,
            -config.impulse.stellar.orbital_change.max_delta_eccentricity,
            config.impulse.stellar.orbital_change.max_delta_eccentricity
        )
        let clamped_dobl = maths.clamp(
            payload.delta_obliquity,
            -config.impulse.stellar.orbital_change.max_delta_obliquity,
            config.impulse.stellar.orbital_change.max_delta_obliquity
        )
        let clamped_dprec = maths.clamp(
            payload.delta_precession,
            -config.impulse.stellar.orbital_change.max_delta_precession,
            config.impulse.stellar.orbital_change.max_delta_precession
        )

        # Apply obliquity change (affects seasonal forcing)
        if maths.abs(clamped_dobl) > config.impulse.stellar.orbital_change.min_significant_obliquity {
            rotation.obliquity <- clamped_dobl
        }

        # Apply precession change (affects seasonal timing relative to perihelion)
        if maths.abs(clamped_dprec) > config.impulse.stellar.orbital_change.min_significant_precession {
            rotation.precession <- clamped_dprec
        }

        # Apply eccentricity change (affects seasonal strength)
        if maths.abs(clamped_de) > config.impulse.stellar.orbital_change.min_significant_eccentricity {
            orbit.eccentricity <- clamped_de
        }
    }
}

# =============================================================================
# Stellar Fields
# =============================================================================

field.stellar.insolation_map {
    : Scalar<W/mÂ²>
    : stratum(orbit)
    : topology(sphere_surface)
    : title("Insolation Field")

    measure {
        stellar.total_insolation
    }
}

field.stellar.tidal_amplitude_map {
    : Scalar<m>
    : stratum(tides)
    : topology(sphere_surface)
    : title("Tidal Amplitude Field")

    measure {
        # Observe the aggregated signal (entity aggregation happens in signal resolve)
        stellar.total_tidal_amplitude
    }
}
