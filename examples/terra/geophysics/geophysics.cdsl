# Terra Geophysics Module
# Core planetary physics: gravity, rotation, thermal dynamics, and tectonics
#
# This module provides the foundational geophysical signals that other
# modules (atmosphere, hydrology, ecology) depend on.
#
# =============================================================================
# Limitations (see issue #182)
# =============================================================================
#
# The following old reference (Rust) structures cannot be directly represented
# in the current CDSL due to language constraints:
#
# 1. CrustSurface (per-sample-point arrays):
#    - elevation_m: Vec<f32>
#    - thickness_m: Vec<f32>
#    CDSL does not support variable-length arrays. These are represented as
#    aggregate scalar signals (crust.elevation, crust.thickness).
#
# 2. CrustLayers (layered shell structures):
#    - shells: Vec<LayerShell> with composition arrays per shell
#    CDSL entities are flat collections. Multi-level hierarchies require
#    multiple entity types or runtime spatial sampling.
#
# 3. PlateBoundarySegments (typed segment lists):
#    - segments: Vec<BoundarySegment> with per-segment BoundaryType
#    Segment-level classification requires runtime spatial analysis.
#    Provided instead: activity proxy signals (divergent_activity,
#    convergent_activity, transform_activity) for aggregate estimates.
#
# These limitations are architectural - CDSL signals are single values or
# entity-associated members, not spatial arrays. Spatial data structures
# are handled by the runtime's Field and Lens systems.
# =============================================================================

# =============================================================================
# Geophysics Functions
# =============================================================================

# Compute isostatic buoyancy factor from density contrast
fn isostasy.buoyancy_factor(crustal_density, mantle_density) {
    1.0 - crustal_density / mantle_density
}

# Compute isostatic elevation from thickness, factor, and reference level
fn isostasy.compute_elevation(thickness, factor, reference_level) {
    factor * thickness - reference_level
}

# Compute lithostatic pressure at depth
fn pressure.lithostatic(surface_pressure, density, gravity, depth) {
    surface_pressure + density * gravity * depth
}

# Compute geothermal temperature at depth
fn thermal.geothermal_temp(surface_temp, gradient, depth_km) {
    surface_temp + gradient * depth_km
}

# =============================================================================
# Geophysics Constants
# =============================================================================

const {
    # Fundamental physics
    physics.gravitational: 6.67430e-11 <m³·kg⁻¹·s⁻²>
    physics.stefan_boltzmann: 5.67e-8 <W·m⁻²·K⁻⁴>

    # Earth reference values
    earth.mass: 5.972e24 <kg>
    earth.radius: 6.371e6 <m>
    earth.gravity: 9.80665 <m/s²>
    earth.gravitational_parameter: 3.986e14 <m³/s²>

    # Crust properties
    crust.density_continental: 2700.0 <kg/m³>
    crust.density_oceanic: 2900.0 <kg/m³>
    mantle.density: 3300.0 <kg/m³>

    # Isostasy
    isostasy.reference_thickness: 35000.0 <m>

    # Dynamic topography
    topography.max_plume_uplift: 2000.0 <m>
    topography.max_slab_depression: 1000.0 <m>

    # Thermal
    thermal.surface_temp: 288.0 <K>
    thermal.gradient: 25.0 <K/km>
    thermal.mantle_temp: 1600.0 <K>

    # Radiogenic decay
    thermal.radiogenic_halflife_gyr: 2.5 <Gyr>

    # Rotation
    rotation.earth_omega: 7.292e-5 <rad/s>
}

# =============================================================================
# Geophysics Configuration
# =============================================================================

config {
    # Planet parameters
    planet.mass: 5.972e24
    planet.radius: 6.371e6

    # Crust configuration
    crust.initial_thickness: 35000.0
    crust.min_thickness: 3000.0
    crust.max_thickness: 80000.0
    crust.density: 2700.0

    # Isostasy configuration
    isostasy.crustal_density: 2700.0
    isostasy.mantle_density: 3300.0

    # Topography
    topography.flow_coupling: 1.0
    elevation.max_depth: 11000.0
    elevation.max_height: 9000.0

    # Thermal
    thermal.decay_halflife: 4.5e17 <s>
    thermal.surface_heat_flow: 0.065
    thermal.conductivity: 2.5

    # Initial values
    core.initial_temp: 5500.0
    mantle.initial_temp: 1600.0
    surface.initial_temp: 288.0
    surface.initial_heat_flow: 0.065
    crust.initial_density: 2700.0
    crust.initial_elevation: 0.0
    crust.initial_pressure_base: 1e9
    crust.initial_temp_base: 1163.0
    crust.initial_moho_depth: 35000.0
    isostasy.initial_factor: 0.182
    isostasy.initial_reference_level: 6370.0
    isostasy.initial_elevation: 0.0
    topography.initial_dynamic_offset: 0.0
    tectonics.initial_boundary_stress: 0.0
    planet.initial_radius: 6.371e6
    planet.initial_mass: 5.972e24
    planet.initial_gravity_mu: 3.986e14
    planet.initial_surface_gravity: 9.81

    # Rotation initial values
    rotation.initial_phase: 0.0
    rotation.initial_omega: 7.292e-5
    spin.initial_obliquity: 0.409
    spin.initial_precession: 0.0

    # Mantle flow
    mantle.initial_heat_content: 8.0e30
    core.initial_heat_power: 4.0e13

    # Tectonic activity
    tectonics.initial_activity: 1.0
    tectonics.reference_shear: 30.0
    tectonics.initial_plate_count: 12

    # Plate entity configuration
    plates.count: 12
    plates.min_count: 5
    plates.max_count: 50
    plates.oceanic_fraction: 0.71
    plates.max_oceanic_age_myr: 280.0
    plates.age_min_myr: 0.0
    plates.age_max_myr: 4000.0
    plates.thickness_min_m: 5000.0
    plates.thickness_max_m: 70000.0
    plates.continental_thickness_threshold_m: 30000.0
    plates.buoyancy_min: 0.0
    plates.buoyancy_max: 1.0
    plates.continental_buoyancy_threshold: 0.5
}

# =============================================================================
# Core Planetary Signals
# =============================================================================

signal planet.radius {
    : Scalar<m, 1e6..1e8>
    : strata(genesis)
    : title("Planet Radius")
    : symbol("R")

    resolve {
        config.planet.radius
    }

    assert {
        prev >= 1e6 : fatal, "Planet radius below minimum"
        prev <= 1e8 : fatal, "Planet radius above maximum"
    }
}

signal planet.mass {
    : Scalar<kg, 1e22..1e28>
    : strata(genesis)
    : title("Planet Mass")
    : symbol("M")

    resolve {
        config.planet.mass
    }

    assert {
        prev >= 1e22 : fatal, "Planet mass below minimum"
        prev <= 1e28 : fatal, "Planet mass above maximum"
    }
}

# Gravitational parameter mu = G * M
signal planet.gravity_mu {
    : Scalar<m³/s², 1e12..1e18>
    : strata(genesis)
    : title("Gravitational Parameter")
    : symbol("mu")

    resolve {
        const.physics.gravitational * signal.planet.mass
    }

    assert {
        prev >= 1e12 : fatal, "Gravitational parameter below minimum"
        prev <= 1e18 : fatal, "Gravitational parameter above maximum"
    }
}

# Surface gravity g = mu / R^2
signal planet.surface_gravity {
    : Scalar<m/s², 1..50>
    : strata(genesis)
    : title("Surface Gravity")
    : symbol("g")

    resolve {
        signal.planet.gravity_mu / (signal.planet.radius * signal.planet.radius)
    }

    assert {
        prev >= 1.0 : warn, "Surface gravity unusually low"
        prev <= 50.0 : warn, "Surface gravity unusually high"
    }
}

# =============================================================================
# Rotation Signals (from old geophysics/signals.rs)
# =============================================================================

# Rotation state: phase and angular velocity
signal rotation.state {
    : Vec2<rad>
    : strata(rotation)
    : title("Rotation State")
    : symbol("theta,omega")

    config {
        initial_phase: 0.0
        initial_omega: 7.292e-5
    }

    resolve {
        # Phase advances with angular velocity using integrate
        let phase = dt.integrate(prev.x, prev.y) in
        let omega = prev.y + inputs in
        vector.vec2(maths.mod(phase, TAU), omega)
    }

    assert {
        prev.y >= 0.0 : warn, "Angular velocity should be non-negative"
        prev.y <= 1e-3 : warn, "Angular velocity exceeds physical limits"
    }
}

# Axial obliquity (tilt angle from ecliptic normal)
# Earth: ~23.4 degrees = 0.409 rad
signal rotation.obliquity {
    : Scalar<rad, 0..PI>
    : strata(rotation)
    : title("Axial Obliquity")
    : symbol("epsilon")

    config {
        initial: 0.409
        precession_rate: 0.0  # rad/s, can evolve via tidal effects
    }

    resolve {
        # Obliquity can evolve due to tidal torques and perturbations
        prev + inputs
    }

    assert {
        prev >= 0.0 : warn, "Obliquity cannot be negative"
        prev <= PI : warn, "Obliquity cannot exceed PI"
    }
}

# Precession angle (rotation of spin axis around ecliptic normal)
# Earth: completes one cycle in ~26,000 years
signal rotation.precession {
    : Scalar<rad, 0..TAU>
    : strata(rotation)
    : title("Precession Angle")
    : symbol("psi")

    config {
        initial: 0.0
        rate: 7.7e-12  # rad/s, ~26,000 year period
    }

    resolve {
        # Precession advances at a rate determined by torques
        maths.mod(dt.integrate(prev, config.rotation.precession.rate) + inputs, TAU)
    }

    assert {
        prev >= 0.0 : warn, "Precession angle cannot be negative"
        prev <= TAU : warn, "Precession angle cannot exceed TAU"
    }
}

# Spin axis in world coordinates (computed from obliquity and precession)
# +Y is ecliptic normal, spin axis tilts from +Y by obliquity
signal rotation.spin_axis {
    : Vec3<1>
    : strata(rotation)
    : title("Spin Axis World")
    : symbol("n_spin")

    resolve {
        # Compute unit vector from spherical angles
        # obliquity = angle from +Y axis
        # precession = rotation around Y axis in XZ plane
        let obl = signal.rotation.obliquity in
        let prec = signal.rotation.precession in
        let sin_obl = maths.sin(obl) in
        let cos_obl = maths.cos(obl) in
        vector.vec3(
            sin_obl * maths.sin(prec),   # x component
            cos_obl,               # y component (ecliptic normal)
            sin_obl * maths.cos(prec)    # z component
        )
    }

    assert {
        maths.abs(vector.length(prev) - 1.0) < 0.01 : warn, "Spin axis should be unit vector"
    }
}

# =============================================================================
# Thermal Signals
# =============================================================================

signal core.temp {
    : Scalar<K, 100..10000>
    : strata(thermal)
    : title("Core Temperature")
    : symbol("T_core")

    config {
        decay_halflife: 4.5e17 <s>
    }

    resolve {
        dt.decay(prev, config.core.temp.decay_halflife) + inputs
    }

    assert {
        prev >= 100 <K>
        prev <= 10000 <K>
        prev > 0 : fatal, "Core temperature must be positive"
    }
}

# Core heat power - net power from core to mantle
signal core.heat_power {
    : Scalar<W, 0..1e15>
    : strata(thermal)
    : title("Core Heat Power")
    : symbol("P_core")

    config {
        initial_power: 4.0e13
        radiogenic_halflife_gyr: 2.5
    }

    resolve {
        # Radiogenic decay reduces heat production over time
        # Earth's core heat flow is ~2-6 TW
        # Clamp to prevent negative accumulation from heat budget fracture
        maths.max(dt.decay(prev, config.core.heat_power.radiogenic_halflife_gyr * 3.1536e16) + inputs, 0.0 <W>)
    }

    assert {
        prev >= 0.0 : warn, "Core heat power cannot be negative"
        prev <= 1e15 : warn, "Core heat power exceeds physical maximum"
    }
}

# Mantle heat content - thermal reservoir
signal mantle.heat_content {
    : Scalar<J, 1e28..1e32>
    : strata(thermal)
    : title("Mantle Heat Content")
    : symbol("Q_mantle")

    config {
        initial_heat: 8.0e30
    }

    resolve {
        # Heat content changes with net power input: dQ/dt = P_in
        # Earth's mantle: mass ~4e24 kg, Cp ~1200 J/kg/K, T ~1600K = 8e30 J
        dt.integrate(prev, signal.core.heat_power) + inputs
    }

    assert {
        prev >= 1e28 : warn, "Mantle heat content below minimum"
        prev <= 1e32 : warn, "Mantle heat content above maximum"
    }
}

signal mantle.temp {
    : Scalar<K, 500..5000>
    : strata(thermal)
    : uses(maths.clamping)
    : title("Mantle Temperature")

    config {
        core_coupling_factor: 0.01
        min_temp: 500.0
        max_temp: 5000.0
    }

    resolve {
        let core_coupling = (signal.core.temp - prev) * config.mantle.temp.core_coupling_factor in
        maths.clamp(prev + core_coupling + inputs, config.mantle.temp.min_temp, config.mantle.temp.max_temp)
    }

    assert {
        prev >= config.mantle.temp.min_temp : warn, "Mantle temperature below minimum"
        prev <= config.mantle.temp.max_temp : warn, "Mantle temperature above maximum"
    }
}

signal surface.temp {
    : Scalar<K, 50..500>
    : strata(thermal)
    : title("Surface Temperature")

    const {
        geothermal_contribution: 0.875
    }

    resolve {
        const.thermal.surface_temp + const.surface.temp.geothermal_contribution + inputs
    }

    assert {
        prev >= 50.0 : warn, "Surface temperature below habitable range"
        prev <= 500.0 : warn, "Surface temperature above habitable range"
    }
}

signal surface.heat_flow {
    : Scalar<W/m², 0.01..0.5>
    : strata(thermal)
    : uses(maths.clamping)
    : title("Surface Heat Flow")
    : symbol("q")

    config {
        baseline: 0.065
        conductivity: 2.5
    }

    resolve {
        let thermal_contribution = (signal.mantle.temp - signal.surface.temp) * 0.00001 in
        maths.clamp(config.surface.heat_flow.baseline + thermal_contribution + inputs, 0.01, 0.5)
    }

    assert {
        prev >= 0.01 : warn, "Heat flow below realistic minimum"
        prev <= 0.5 : warn, "Heat flow above realistic maximum"
    }
}

# =============================================================================
# Crust Signals - Isostasy Implementation
# =============================================================================

signal crust.density {
    : Scalar<kg/m³, 2000..3500>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Crustal Density")
    : symbol("rho_crust")

    config {
        continental: 2700.0 <kg/m³>
        oceanic: 2900.0 <kg/m³>
        min: 2000.0 <kg/m³>
        max: 3500.0 <kg/m³>
    }

    resolve {
        maths.clamp(prev + inputs, config.crust.density.min, config.crust.density.max)
    }

    assert {
        prev >= config.crust.density.min : warn, "Crustal density below minimum"
        prev <= config.crust.density.max : warn, "Crustal density above maximum"
    }
}

signal crust.thickness {
    : Scalar<m, 3000..80000>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Crustal Thickness")
    : symbol("h_crust")

    config {
        min: 3000.0 <m>
        max: 80000.0 <m>
    }

    resolve {
        # inputs contains deltas from fractures (both continuous and discrete)
        # Note: continuous processes assume dt ~1 Myr for rate configs
        maths.clamp(prev + inputs, config.crust.thickness.min, config.crust.thickness.max)
    }

    assert {
        prev >= config.crust.thickness.min : warn, "Crust thinning below minimum"
        prev <= config.crust.thickness.max : warn, "Crust thickening above maximum"
    }
}

signal crust.total_thickness {
    : Scalar<m, 0..100000>
    : strata(tectonics)
    : title("Total Crustal Thickness")

    resolve {
        signal.crust.thickness
    }

    assert {
        prev >= 0.0 : warn, "Total thickness cannot be negative"
        prev <= 100000.0 : warn, "Total thickness exceeds maximum"
    }
}

# Isostatic factor: 1 - (crust_density / mantle_density)
signal isostasy.factor {
    : Scalar<1, 0..1>
    : strata(tectonics)
    : title("Isostatic Factor")

    config {
        crustal_density: 2700.0
        mantle_density: 3300.0
    }

    resolve {
        isostasy.buoyancy_factor(config.isostasy.factor.crustal_density, config.isostasy.factor.mantle_density)
    }

    assert {
        prev >= 0.0 : warn, "Isostatic factor cannot be negative"
        prev <= 1.0 : warn, "Isostatic factor cannot exceed 1"
    }
}

signal isostasy.reference_level {
    : Scalar<m, 0..10000>
    : strata(tectonics)
    : title("Isostatic Reference Level")

    resolve {
        signal.isostasy.factor * const.isostasy.reference_thickness
    }

    assert {
        prev >= 0.0 : warn, "Reference level cannot be negative"
        prev <= 10000.0 : warn, "Reference level exceeds maximum"
    }
}

signal isostasy.elevation {
    : Scalar<m, -15000..15000>
    : strata(tectonics)
    : title("Isostatic Elevation")

    resolve {
        isostasy.compute_elevation(signal.crust.thickness, signal.isostasy.factor, signal.isostasy.reference_level)
    }

    assert {
        prev >= -15000.0 : warn, "Isostatic elevation below minimum"
        prev <= 15000.0 : warn, "Isostatic elevation above maximum"
    }
}

# =============================================================================
# Dynamic Topography
# =============================================================================

signal topography.dynamic_offset {
    : Scalar<m, -1200..2400>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Dynamic Topography Offset")

    config {
        flow_coupling: 1.0
        uplift_scale: 0.01
    }

    resolve {
        let thermal_gradient = (signal.mantle.temp - const.thermal.mantle_temp) / 1000.0 in
        let uplift = thermal_gradient * const.topography.max_plume_uplift * config.topography.dynamic_offset.flow_coupling * config.topography.dynamic_offset.uplift_scale in
        maths.clamp(
            prev + uplift + inputs,
            -const.topography.max_slab_depression,
            const.topography.max_plume_uplift
        )
    }

    assert {
        prev >= -const.topography.max_slab_depression : warn, "Dynamic offset below slab depression limit"
        prev <= const.topography.max_plume_uplift : warn, "Dynamic offset above plume uplift limit"
    }
}

# =============================================================================
# Combined Elevation
# =============================================================================

signal crust.elevation {
    : Scalar<m, -11000..9000>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Surface Elevation")
    : symbol("h_elev")

    config {
        max_depth: 11000.0 <m>
        max_height: 9000.0 <m>
    }

    resolve {
        # Base elevation from isostasy + dynamic topography + fracture contributions
        # Note: continuous processes assume dt ~1 Myr for rate configs
        maths.clamp(
            signal.isostasy.elevation + signal.topography.dynamic_offset + inputs,
            -config.crust.elevation.max_depth,
            config.crust.elevation.max_height
        )
    }

    assert {
        prev >= -config.crust.elevation.max_depth : warn, "Elevation below maximum ocean depth"
        prev <= config.crust.elevation.max_height : warn, "Elevation above maximum mountain height"
    }
}

# =============================================================================
# Derived Crust Properties
# =============================================================================

signal crust.pressure_base {
    : Scalar<kg/m/s², 1e5..3e9>
    : strata(tectonics)
    : title("Base Crustal Pressure")

    config {
        surface_pressure: 100000.0
        density: 2700.0
        min: 1e5
        max: 3e9
    }

    resolve {
        pressure.lithostatic(config.crust.pressure_base.surface_pressure, config.crust.pressure_base.density, signal.planet.surface_gravity, signal.crust.thickness)
    }

    assert {
        prev >= config.crust.pressure_base.min : warn, "Base pressure below minimum"
        prev <= config.crust.pressure_base.max : warn, "Base pressure above maximum"
    }
}

signal crust.temp_base {
    : Scalar<K, 300..1500>
    : strata(thermal)
    : title("Base Crustal Temperature")

    resolve {
        thermal.geothermal_temp(const.thermal.surface_temp, const.thermal.gradient, signal.crust.thickness / 1000.0)
    }

    assert {
        prev >= 300.0 : warn, "Base temperature below minimum"
        prev <= 1500.0 : warn, "Base temperature above maximum"
    }
}

signal crust.moho_depth {
    : Scalar<m, 3000..80000>
    : strata(tectonics)
    : title("Moho Depth")

    resolve {
        signal.crust.thickness
    }

    assert {
        prev >= 3000.0 : warn, "Moho depth below minimum crustal thickness"
        prev <= 80000.0 : warn, "Moho depth above maximum crustal thickness"
    }
}

# =============================================================================
# Tectonic Signals
# =============================================================================

signal tectonics.boundary_stress {
    : Scalar<N/m², 0..1e9>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Plate Boundary Stress")

    config {
        thermal_factor: 0.001
        thermal_scale: 1e4
        thickness_factor: 0.001
        thickness_scale: 1e3
        max_stress: 1e9
        reference_mantle_temp: 1600.0
    }

    resolve {
        let thermal_stress = maths.abs(signal.mantle.temp - config.tectonics.boundary_stress.reference_mantle_temp) * config.tectonics.boundary_stress.thermal_scale * config.tectonics.boundary_stress.thermal_factor in
        let thickness_stress = maths.abs(signal.crust.thickness - const.isostasy.reference_thickness) * config.tectonics.boundary_stress.thickness_scale * config.tectonics.boundary_stress.thickness_factor in
        maths.clamp(prev + thermal_stress + thickness_stress + inputs, 0.0, config.tectonics.boundary_stress.max_stress)
    }

    assert {
        prev >= 0.0 : warn, "Boundary stress cannot be negative"
        prev <= config.tectonics.boundary_stress.max_stress : warn, "Boundary stress exceeds maximum"
    }
}

# Tectonic activity index (from old signals.rs)
signal tectonics.activity {
    : Scalar<1, 0..100>
    : strata(tectonics)
    : title("Tectonic Activity")
    : symbol("A_tec")

    config {
        reference_shear: 30.0
    }

    resolve {
        # Activity index normalized to 1.0 for Earth-like tectonics
        let raw_shear = inputs in
        if raw_shear > 0.0 {
            raw_shear / config.tectonics.activity.reference_shear
        } else {
            prev
        }
    }

    assert {
        prev >= 0.0 : warn, "Tectonic activity cannot be negative"
        prev <= 100.0 : warn, "Tectonic activity exceeds maximum"
    }
}

# Plate count diagnostic (now derived from plate entity)
signal tectonics.plate_count {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Plate Count")

    resolve {
        agg.count(entity.terra.plate)
    }

    assert {
        prev >= 0.0 : warn, "Plate count cannot be negative"
        prev <= 64.0 : warn, "Plate count exceeds maximum"
    }
}

# Mantle viscosity diagnostic
signal mantle.viscosity {
    : Scalar<Pa*s, 0..1e24>
    : strata(tectonics)
    : title("Mantle Viscosity")
    : symbol("eta")

    config {
        initial: 1e21 <Pa*s>  # Earth's effective mantle viscosity (Pa*s)
    }

    resolve {
        if prev == 0.0 <Pa*s> {
            config.mantle.viscosity.initial
        } else {
            prev + inputs
        }
    }

    assert {
        prev >= 0.0 : warn, "Viscosity cannot be negative"
    }
}

# =============================================================================
# Mantle Convection Signals (from old mantle_flow.rs)
# =============================================================================

# Effective Rayleigh number - dimensionless measure of convection vigor
# Ra ~ Q/ν (heat power / viscosity) normalized to Earth-like conditions
signal mantle.rayleigh_number {
    : Scalar<1, 0..1e10>
    : strata(tectonics)
    : title("Effective Rayleigh Number")
    : symbol("Ra")

    config {
        reference_heat_power: 4.0e13   # W (40 TW, Earth reference)
        reference_viscosity: 1.0e21    # Pa*s (Earth reference)
    }

    resolve {
        # Normalized Rayleigh: Ra_eff ~ (Q/Q_ref) / (ν/ν_ref)
        let q_norm = signal.core.heat_power / config.mantle.rayleigh_number.reference_heat_power in
        let nu_norm = signal.mantle.viscosity / config.mantle.rayleigh_number.reference_viscosity in
        if nu_norm > 0.0 {
            q_norm / nu_norm
        } else {
            1.0
        }
    }

    assert {
        prev >= 0.0 : warn, "Rayleigh number cannot be negative"
    }
}

# Convection cell count - derived from Rayleigh number
# More vigorous convection produces more cells
signal mantle.convection_cells {
    : Scalar<1, 2..12>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Convection Cell Count")
    : symbol("N_cells")

    config {
        reference_ra: 1.0e6            # Reference Rayleigh number
        mode_count: 4                  # Earth-like cell count
        exponent: 0.4                  # Scaling exponent
        min_count: 2
        max_count: 12
    }

    resolve {
        # n = mode * (Ra / Ra_ref)^exponent
        # Guard against negative Rayleigh (would cause NaN in pow with fractional exponent)
        let ra = maths.max(signal.mantle.rayleigh_number, 0.0) in
        let ratio = ra / config.mantle.convection_cells.reference_ra in
        let n = config.mantle.convection_cells.mode_count * maths.pow(ratio, config.mantle.convection_cells.exponent) in
        maths.clamp(n, config.mantle.convection_cells.min_count, config.mantle.convection_cells.max_count)
    }

    assert {
        prev >= 2.0 : warn, "Convection cells below minimum"
        prev <= 12.0 : warn, "Convection cells above maximum"
    }
}

# Mantle flow strength - vortex velocity scale (cm/yr)
# Higher heat power drives more vigorous convection
signal mantle.flow_strength {
    : Scalar<cm/yr, 0..50>
    : strata(tectonics)
    : title("Mantle Flow Strength")
    : symbol("v_mantle")

    config {
        base_strength: 5.0             # cm/yr (typical Earth mantle)
        reference_heat_power: 4.0e13   # W
        exponent: 0.3                  # Strength scaling exponent
    }

    resolve {
        # strength ~ base * (Q/Q_ref)^exponent
        let ratio = signal.core.heat_power / config.mantle.flow_strength.reference_heat_power in
        let scale = maths.pow(maths.max(ratio, 0.0), config.mantle.flow_strength.exponent) in
        config.mantle.flow_strength.base_strength * scale + inputs
    }

    assert {
        prev >= 0.0 : warn, "Flow strength cannot be negative"
    }
}

# =============================================================================
# Advanced Tectonic Signals
# =============================================================================

# Orogeny rate - rate of mountain building from plate collisions
signal tectonics.orogeny_rate {
    : Scalar<m/Myr, 0..10000>
    : strata(tectonics)
    : title("Orogeny Rate")
    : symbol("dh/dt")

    config {
        stress_factor: 1e-8            # Conversion from stress to uplift rate
        activity_factor: 100.0         # Base rate per unit activity
    }

    resolve {
        # Orogeny driven by boundary stress and tectonic activity
        let stress_contribution = signal.tectonics.boundary_stress * config.tectonics.orogeny_rate.stress_factor in
        let activity_contribution = signal.tectonics.activity * config.tectonics.orogeny_rate.activity_factor in
        stress_contribution + activity_contribution + inputs
    }

    assert {
        prev >= 0.0 : warn, "Orogeny rate cannot be negative"
    }
}

# Volcanism index - volcanic activity level from thermal state
signal tectonics.volcanism {
    : Scalar<1, 0..100>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Volcanism Index")
    : symbol("V_idx")

    config {
        reference_mantle_temp: 1600.0  # K
        temp_sensitivity: 0.01         # Index per K above reference
        flow_factor: 0.5               # Contribution from mantle flow
    }

    resolve {
        # Volcanism driven by excess mantle temperature and convection strength
        let temp_excess = maths.max(signal.mantle.temp - config.tectonics.volcanism.reference_mantle_temp, 0.0) in
        let temp_contribution = temp_excess * config.tectonics.volcanism.temp_sensitivity in
        let flow_contribution = signal.mantle.flow_strength * config.tectonics.volcanism.flow_factor in
        maths.clamp(temp_contribution + flow_contribution + inputs, 0.0, 100.0)
    }

    assert {
        prev >= 0.0 : warn, "Volcanism index cannot be negative"
        prev <= 100.0 : warn, "Volcanism index exceeds maximum"
    }
}

# Subduction rate - rate at which oceanic crust is recycled
signal tectonics.subduction_rate {
    : Scalar<km²/Myr, 0..10>
    : strata(tectonics)
    : title("Subduction Rate")
    : symbol("A_sub")

    config {
        velocity_factor: 1e-6          # Conversion from plate velocity
        boundary_factor: 0.1           # Factor for boundary length contribution
    }

    resolve {
        # Subduction rate driven by plate velocities and convergent boundaries
        let velocity_contribution = signal.plates.boundary_shear * 1e6 * config.tectonics.subduction_rate.velocity_factor in
        let oceanic_fraction = signal.plates.oceanic_count / maths.max(signal.plates.count, 1.0) in
        velocity_contribution * oceanic_fraction * signal.tectonics.activity + inputs
    }

    assert {
        prev >= 0.0 : warn, "Subduction rate cannot be negative"
    }
}

# Seafloor spreading rate - rate of new oceanic crust creation
signal tectonics.spreading_rate {
    : Scalar<km²/Myr, 0..10>
    : strata(tectonics)
    : title("Seafloor Spreading Rate")
    : symbol("A_spread")

    config {
        mantle_coupling: 0.2           # Coupling to mantle flow
    }

    resolve {
        # Spreading rate roughly balances subduction over long timescales
        # Driven by mantle upwelling strength
        let flow_contribution = signal.mantle.flow_strength * config.tectonics.spreading_rate.mantle_coupling in
        let activity_contribution = signal.tectonics.activity in
        flow_contribution * activity_contribution + inputs
    }

    assert {
        prev >= 0.0 : warn, "Spreading rate cannot be negative"
    }
}

# =============================================================================
# Tectonic Plate Entity
# =============================================================================

entity terra.plate {
    : count(config.plates.count)
    : count(5..64)
}

# -----------------------------------------------------------------------------
# Plate Physical Properties
# -----------------------------------------------------------------------------

# Plate type: 0 = oceanic, 1 = continental
# Initialized via scenario or worldgen; 0 = oceanic, 1 = continental
member terra.plate.kind {
    : Scalar<1, 0..1>
    : strata(tectonics)
    : title("Plate Type")
    : symbol("k_plate")

    # Default to oceanic (0.0); scenario/worldgen can override
    initial { 0.0 }

    resolve { prev + inputs }
}

# Plate age in millions of years
# Oceanic plates age and eventually subduct; continental plates can be billions of years old
member terra.plate.age {
    : Scalar<Myr, 0..5000>
    : strata(tectonics)
    : title("Plate Age")
    : symbol("t_plate")

    config {
        max_oceanic_age_myr: 280.0
        initial_age_myr: 100.0
    }

    initial { config.terra.plate.age.initial_age_myr }

    resolve {
        # Plates age with simulation time (rate = 1 Myr per 3.1536e13 seconds)
        # Oceanic plates are capped at max age (subduction recycling)
        let new_age = dt.integrate(prev, 3.1688e-14) in  # 1/3.1536e13 Myr/s
        if self.kind < 0.5 {
            # Oceanic: cap at max age
            maths.min(new_age, config.terra.plate.age.max_oceanic_age_myr)
        } else {
            # Continental: no cap
            new_age
        }
    }

    assert {
        prev >= 0.0 : warn, "Plate age cannot be negative"
    }
}

# Plate lithosphere thickness
member terra.plate.thickness {
    : Scalar<m, 5000..70000>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Plate Thickness")
    : symbol("h_plate")

    config {
        initial_thickness_m: 35000.0
    }

    initial { config.terra.plate.thickness.initial_thickness_m }

    resolve {
        maths.clamp(prev + inputs, 5000.0, 70000.0)
    }

    assert {
        prev >= 5000.0 : warn, "Plate thickness below minimum"
        prev <= 70000.0 : warn, "Plate thickness above maximum"
    }
}

# Plate buoyancy (0 = dense/subductable, 1 = buoyant/resistant)
# Lower buoyancy = more likely to subduct
member terra.plate.buoyancy {
    : Scalar<1, 0..1>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Plate Buoyancy")
    : symbol("b_plate")

    config {
        initial_buoyancy: 0.3
    }

    initial { config.terra.plate.buoyancy.initial_buoyancy }

    resolve {
        maths.clamp(prev + inputs, 0.0, 1.0)
    }

    assert {
        prev >= 0.0 : warn, "Plate buoyancy cannot be negative"
        prev <= 1.0 : warn, "Plate buoyancy cannot exceed 1"
    }
}

# -----------------------------------------------------------------------------
# Plate Geometry (seed direction on sphere)
# -----------------------------------------------------------------------------

# Plate seed direction in body frame (unit vector defining plate center)
member terra.plate.seed_direction {
    : Vec3<1>
    : strata(tectonics)
    : title("Plate Seed Direction")
    : symbol("n_plate")

    # Default to +Z axis; scenario/worldgen distributes plates over sphere
    initial { vector.vec3(0.0, 0.0, 1.0) }

    resolve {
        # Normalize to maintain unit vector
        vector.normalize(prev + inputs)
    }

    assert {
        maths.abs(vector.length(prev) - 1.0) < 0.01 : warn, "Plate seed should be unit vector"
    }
}

# -----------------------------------------------------------------------------
# Plate Kinematics
# -----------------------------------------------------------------------------

# Plate angular velocity (rotation axis and rate in body frame)
member terra.plate.omega {
    : Vec3<rad/s>
    : strata(tectonics)
    : title("Plate Angular Velocity")
    : symbol("omega_plate")

    config {
        scale: 1.0
    }

    # Start at rest; mantle flow will drive plate motion
    initial { vector.vec3(0.0, 0.0, 0.0) }

    resolve {
        # Plate motion derived from mantle flow and inputs impulses
        config.terra.plate.omega.scale * (prev + inputs)
    }
}

# Plate surface velocity magnitude at equator of rotation
member terra.plate.velocity {
    : Scalar<m/s, 0..1>
    : strata(tectonics)
    : title("Plate Velocity")
    : symbol("v_plate")

    resolve {
        # v = omega * R (velocity at planet radius)
        vector.length(self.omega) * signal.planet.radius
    }

    assert {
        prev >= 0.0 : warn, "Plate velocity cannot be negative"
    }
}

# -----------------------------------------------------------------------------
# Aggregate Plate Signals
# -----------------------------------------------------------------------------

# Number of plates (derived from entity count)
signal plates.count {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Number of Plates")
    : symbol("N_plates")

    resolve {
        agg.count(entity.terra.plate)
    }
}

# Mean plate age
signal plates.mean_age {
    : Scalar<Myr, 0..5000>
    : strata(tectonics)
    : title("Mean Plate Age")
    : symbol("t_mean")

    resolve {
        agg.mean(entity.terra.plate, self.age)
    }
}

# Mean plate thickness
signal plates.mean_thickness {
    : Scalar<m, 5000..70000>
    : strata(tectonics)
    : title("Mean Plate Thickness")
    : symbol("h_mean")

    resolve {
        agg.mean(entity.terra.plate, self.thickness)
    }
}

# Oceanic plate count
signal plates.oceanic_count {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Oceanic Plate Count")
    : symbol("N_oceanic")

    resolve {
        agg.sum(entity.terra.plate, if self.kind < 0.5 { 1.0 } else { 0.0 })
    }
}

# Continental plate count
signal plates.continental_count {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Continental Plate Count")
    : symbol("N_continental")

    resolve {
        agg.sum(entity.terra.plate, if self.kind >= 0.5 { 1.0 } else { 0.0 })
    }
}

# Maximum boundary shear (approximation from plate velocities)
signal plates.boundary_shear {
    : Scalar<m/s, 0..1>
    : strata(tectonics)
    : title("Plate Boundary Shear")
    : symbol("tau_boundary")

    resolve {
        # Approximate shear as max velocity difference between plates
        let max_v = agg.max(entity.terra.plate, self.velocity) in
        let min_v = agg.min(entity.terra.plate, self.velocity) in
        max_v - min_v + inputs
    }
}

# -----------------------------------------------------------------------------
# Enhanced Plate Catalog Aggregates
# Provides additional statistics from the plate entity collection
# -----------------------------------------------------------------------------

# Mean plate buoyancy
signal plates.mean_buoyancy {
    : Scalar<1, 0..1>
    : strata(tectonics)
    : title("Mean Plate Buoyancy")
    : symbol("b_mean")

    resolve {
        agg.mean(entity.terra.plate, self.buoyancy)
    }
}

# Total buoyancy (proxy for continental mass)
signal plates.total_buoyancy {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Total Plate Buoyancy")
    : symbol("b_sum")

    resolve {
        agg.sum(entity.terra.plate, self.buoyancy)
    }
}

# Maximum plate age (oldest plate)
signal plates.max_age {
    : Scalar<Myr, 0..5000>
    : strata(tectonics)
    : title("Maximum Plate Age")
    : symbol("t_max")

    resolve {
        agg.max(entity.terra.plate, self.age)
    }
}

# Minimum plate age (youngest plate)
signal plates.min_age {
    : Scalar<Myr, 0..5000>
    : strata(tectonics)
    : title("Minimum Plate Age")
    : symbol("t_min")

    resolve {
        agg.min(entity.terra.plate, self.age)
    }
}

# Total crustal area proxy (sum of thicknesses as volume proxy)
signal plates.total_thickness {
    : Scalar<m, 0..1000000>
    : strata(tectonics)
    : title("Total Plate Thickness")
    : symbol("h_sum")

    resolve {
        agg.sum(entity.terra.plate, self.thickness)
    }
}

# -----------------------------------------------------------------------------
# Plate Motion Aggregates
# Statistics for plate kinematics across the plate catalog
# -----------------------------------------------------------------------------

# Mean plate velocity magnitude
signal plates.mean_velocity {
    : Scalar<m/s, 0..1>
    : strata(tectonics)
    : title("Mean Plate Velocity")
    : symbol("v_mean")

    resolve {
        agg.mean(entity.terra.plate, self.velocity)
    }
}

# Maximum plate velocity
signal plates.max_velocity {
    : Scalar<m/s, 0..1>
    : strata(tectonics)
    : title("Maximum Plate Velocity")
    : symbol("v_max")

    resolve {
        agg.max(entity.terra.plate, self.velocity)
    }
}

# Minimum plate velocity
signal plates.min_velocity {
    : Scalar<m/s, 0..0.1>
    : strata(tectonics)
    : title("Minimum Plate Velocity")
    : symbol("v_min")

    resolve {
        agg.min(entity.terra.plate, self.velocity)
    }
}

# Mean angular velocity magnitude
signal plates.mean_omega {
    : Scalar<rad/s, 0..1e-8>
    : strata(tectonics)
    : title("Mean Angular Velocity")
    : symbol("omega_mean")

    resolve {
        agg.mean(entity.terra.plate, vector.length(self.omega))
    }
}

# -----------------------------------------------------------------------------
# Plate Boundary Classification Signals
# Derived estimates for different boundary types based on plate kinematics
# Note: True boundary segment classification requires spatial sampling which
# is implemented in the runtime. These provide aggregate approximations.
# -----------------------------------------------------------------------------

# Velocity variance (high variance indicates diverse plate motions)
signal plates.velocity_variance {
    : Scalar<m²/s², 0..1>
    : strata(tectonics)
    : title("Plate Velocity Variance")
    : symbol("sigma_v²")

    resolve {
        # Variance = E[X²] - E[X]²
        let mean_v = signal.plates.mean_velocity in
        let mean_v_sq = agg.mean(entity.terra.plate, self.velocity * self.velocity) in
        maths.max(mean_v_sq - mean_v * mean_v, 0.0)
    }
}

# Spreading rate proxy - divergent boundary activity
# Estimated from mantle upwelling and plate separation
signal plates.divergent_activity {
    : Scalar<1, 0..10>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Divergent Boundary Activity")
    : symbol("A_div")

    config {
        flow_sensitivity: 0.5
        velocity_sensitivity: 10.0
    }

    resolve {
        # Divergent activity correlates with mantle upwelling and plate velocities
        let flow_factor = signal.mantle.flow_strength * config.plates.divergent_activity.flow_sensitivity in
        let velocity_factor = signal.plates.mean_velocity * config.plates.divergent_activity.velocity_sensitivity in
        maths.clamp(flow_factor + velocity_factor + inputs, 0.0, 10.0)
    }
}

# Subduction rate proxy - convergent boundary activity
# Estimated from oceanic plate area and boundary shear
signal plates.convergent_activity {
    : Scalar<1, 0..10>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Convergent Boundary Activity")
    : symbol("A_conv")

    config {
        shear_sensitivity: 20.0
        oceanic_weight: 0.1
    }

    resolve {
        # Convergent activity driven by boundary shear and oceanic plate count
        let shear_factor = signal.plates.boundary_shear * config.plates.convergent_activity.shear_sensitivity in
        let oceanic_factor = signal.plates.oceanic_count * config.plates.convergent_activity.oceanic_weight in
        maths.clamp(shear_factor * oceanic_factor + inputs, 0.0, 10.0)
    }
}

# Transform fault activity proxy
# Lateral motion without significant convergence or divergence
signal plates.transform_activity {
    : Scalar<1, 0..10>
    : strata(tectonics)
    : uses(maths.clamping)
    : title("Transform Boundary Activity")
    : symbol("A_trans")

    config {
        velocity_variance_weight: 100.0
    }

    resolve {
        # Transform activity correlates with velocity variance (plates moving in different directions)
        let variance_contribution = signal.plates.velocity_variance * config.plates.transform_activity.velocity_variance_weight in
        maths.clamp(variance_contribution + inputs, 0.0, 10.0)
    }
}

# Total boundary activity index
signal plates.total_boundary_activity {
    : Scalar<1, 0..30>
    : strata(tectonics)
    : title("Total Boundary Activity")
    : symbol("A_total")

    resolve {
        signal.plates.divergent_activity + signal.plates.convergent_activity + signal.plates.transform_activity
    }
}

# =============================================================================
# Geophysics Fractures (Tectonic Events)
# =============================================================================

# Rifting: thin crust + high stress -> rift opening
fracture tectonics.rift {
    when {
        signal.crust.thickness < 25000
        signal.tectonics.boundary_stress > 5e8
    }

    emit {
        signal.tectonics.boundary_stress <- -signal.tectonics.boundary_stress * 0.8
        signal.crust.thickness <- -500.0
        signal.topography.dynamic_offset <- 200.0
    }
}

# Orogeny: thick crust + compression -> mountain building
fracture tectonics.orogeny {
    when {
        signal.crust.thickness > 50000
        signal.tectonics.boundary_stress > 7e8
    }

    emit {
        signal.tectonics.boundary_stress <- -signal.tectonics.boundary_stress * 0.6
        signal.crust.thickness <- 1000.0
        signal.topography.dynamic_offset <- -100.0
    }
}

# Volcanism: hot mantle + thin crust -> volcanic activity
fracture thermal.volcanism {
    when {
        signal.mantle.temp > 1800 <K>
        signal.crust.thickness < 30000
    }

    emit {
        signal.mantle.temp <- -50.0
        signal.crust.thickness <- 100.0
        signal.topography.dynamic_offset <- 50.0
    }
}

# Radioactive heating burst
fracture core.decay_heat {
    when {
        signal.core.temp < 5000 <K>
    }

    emit {
        signal.core.temp <- 10.0
    }
}

# -----------------------------------------------------------------------------
# Thermal-Mechanical Coupling (from old fracture.rs)
# -----------------------------------------------------------------------------

# Thermal-mechanical coupling: modulate mantle flow vigor based on heat content.
# Higher mantle heat -> more vigorous convection -> faster plate motion.
fracture thermal.mechanical_coupling {
    : strata(thermal)

    config {
        reference_heat_j: 8.0e30          # Earth-like mantle heat content (J)
        coupling_strength: 0.1            # 0.0 = no coupling, 1.0 = full coupling
        base_flow_strength: 5.0           # cm/yr reference
    }

    when {
        # Activate when heat content deviates significantly from reference
        maths.abs(signal.mantle.heat_content - config.fracture.thermal.mechanical_coupling.reference_heat_j) > 1e29
    }

    emit {
        # Compute heat ratio: >1 means hotter, <1 means cooler
        let ratio = signal.mantle.heat_content / config.fracture.thermal.mechanical_coupling.reference_heat_j in
        let delta = (ratio - 1.0) * config.fracture.thermal.mechanical_coupling.coupling_strength * config.fracture.thermal.mechanical_coupling.base_flow_strength in
        signal.mantle.flow_strength <- delta
    }
}

# -----------------------------------------------------------------------------
# Mantle Heat Budget (from old fracture.rs)
# -----------------------------------------------------------------------------

# Mantle heat budget: models long-term thermal evolution via:
# - Radiogenic heating (decays with time)
# - Core-mantle boundary heat flux
# - Surface heat loss (temperature-dependent)
fracture thermal.heat_budget {
    : strata(thermal)

    config {
        radiogenic_power_w: 2.0e13        # Initial radiogenic power (W)
        radiogenic_halflife_gyr: 2.5      # Radiogenic decay half-life
        surface_loss_coefficient: 1.0e-17 # Surface loss scaling
        core_transfer_efficiency: 0.5     # Core heat transfer efficiency
    }

    when {
        # Always active - continuous heat budget
        signal.mantle.heat_content > 0.0
    }

    emit {
        # Radiogenic heating contribution
        let radiogenic = config.fracture.thermal.heat_budget.radiogenic_power_w in

        # Core heat contribution (from core.heat_power with efficiency)
        # Guard against negative heat power feeding back
        let core_contribution = maths.max(signal.core.heat_power, 0.0) * config.fracture.thermal.heat_budget.core_transfer_efficiency in

        # Surface heat loss (proportional to heat content above reference)
        let reference = 8.0e30 in
        let excess_ratio = signal.mantle.heat_content / reference in
        let surface_loss = excess_ratio * config.fracture.thermal.heat_budget.surface_loss_coefficient * signal.mantle.heat_content in

        # Net power change - cap surface loss to not exceed available heat
        let net_input = radiogenic + core_contribution in
        let capped_loss = maths.min(surface_loss, net_input + maths.max(signal.core.heat_power, 0.0)) in

        # Emit net change (will be non-negative if current heat_power >= 0)
        signal.core.heat_power <- net_input - capped_loss
    }
}

# -----------------------------------------------------------------------------
# Tectonic Uplift/Subsidence (from old fracture.rs)
# -----------------------------------------------------------------------------

# Convergent boundary uplift: plate collision drives crustal thickening
fracture tectonics.convergent_uplift {
    : strata(tectonics)

    config {
        thicken_m_per_myr: 200.0          # Thickening rate (m/Myr)
        uplift_m_per_myr: 500.0           # Uplift rate at full convergence (m/Myr)
        convergence_threshold: 0.01       # Boundary shear threshold for activation
    }

    when {
        signal.plates.boundary_shear > config.fracture.tectonics.convergent_uplift.convergence_threshold
        signal.tectonics.activity > 0.5
    }

    emit {
        # Normalized convergence factor
        let conv_factor = signal.plates.boundary_shear / 0.1 in

        # Emit deltas assuming ~1 Myr timestep (rate configs are per Myr)
        # TODO: These should be true rates with signal dt.integrate() once
        # the DSL supports separate rate/delta channels
        signal.crust.thickness <- conv_factor * config.fracture.tectonics.convergent_uplift.thicken_m_per_myr
        signal.crust.elevation <- conv_factor * config.fracture.tectonics.convergent_uplift.uplift_m_per_myr * 0.001
    }
}

# Divergent boundary subsidence: plate separation drives crustal thinning
fracture tectonics.divergent_subsidence {
    : strata(tectonics)

    config {
        thin_m_per_myr: 150.0             # Thinning rate (m/Myr)
        divergence_threshold: 0.005       # Minimum activity for divergence
    }

    when {
        signal.mantle.flow_strength > 3.0
        signal.crust.thickness > 10000
    }

    emit {
        # Divergence driven by mantle upwelling
        let div_factor = signal.mantle.flow_strength / 10.0 in

        # Emit delta assuming ~1 Myr timestep
        signal.crust.thickness <- -div_factor * config.fracture.tectonics.divergent_subsidence.thin_m_per_myr
        # Instantaneous delta for dynamic offset
        signal.topography.dynamic_offset <- div_factor * 50.0
    }
}

# -----------------------------------------------------------------------------
# Wilson Cycle Dynamics (from old fracture.rs)
# -----------------------------------------------------------------------------

# Plate fragmentation: high boundary shear can rift plates apart
# Creates new oceanic basins between continental fragments
fracture tectonics.wilson_fragmentation {
    : strata(tectonics)

    config {
        fragmentation_period_myr: 400.0   # Mean time between fragmentations
        shear_threshold: 0.1              # Minimum shear for fragmentation
    }

    when {
        # High boundary shear indicates internal strain accumulation
        signal.plates.boundary_shear > config.fracture.tectonics.wilson_fragmentation.shear_threshold
        signal.plates.count > 1
        signal.plates.count < 50
    }

    emit {
        # Fragmentation releases boundary stress and creates new oceanic crust
        signal.tectonics.boundary_stress <- -signal.tectonics.boundary_stress * 0.5
        signal.topography.dynamic_offset <- 100.0
        # Note: actual plate creation requires entity mutation (not yet in CDSL)
    }
}

# Plate merger (supercontinent formation): continental collision merges plates
fracture tectonics.wilson_merger {
    : strata(tectonics)

    config {
        merger_period_myr: 30.0           # Mean time for collision merger
        convergence_threshold: 50.0       # mm/yr equivalent threshold
    }

    when {
        # Continental collision at high convergence rate
        signal.plates.boundary_shear > 0.15
        signal.plates.continental_count > 2
        signal.tectonics.activity > 1.5
    }

    emit {
        # Merger builds mountains and thickens crust
        signal.crust.thickness <- 2000.0
        signal.crust.elevation <- 500.0
        signal.tectonics.boundary_stress <- signal.tectonics.boundary_stress * 0.3
        # Note: actual plate merger requires entity mutation
    }
}

# Subduction recycling: old oceanic plates sink into mantle
fracture tectonics.wilson_subduction {
    : strata(tectonics)

    config {
        subduction_age_threshold_myr: 180.0   # Age at which oceanic crust subducts
        subduction_probability_per_myr: 0.01  # 1% per Myr chance
    }

    when {
        # Old oceanic crust becomes negatively buoyant
        signal.plates.mean_age > config.fracture.tectonics.wilson_subduction.subduction_age_threshold_myr
        signal.plates.oceanic_count > 0
    }

    emit {
        # Subduction releases heat and volatiles to mantle
        signal.mantle.temp <- 10.0
        signal.tectonics.volcanism <- 5.0
        # Note: actual plate removal requires entity mutation
    }
}

# -----------------------------------------------------------------------------
# Plate Motion from Mantle Flow (from old fracture.rs)
# -----------------------------------------------------------------------------

# Derive plate motion from mantle convection
# Mantle flow vortices drive plate angular velocities
fracture tectonics.derive_motion {
    : strata(tectonics)

    config {
        omega_scale: 1e-15               # rad/s per unit flow
        flow_coupling: 0.8               # Coupling strength to mantle
    }

    when {
        signal.mantle.flow_strength > 0.1
        signal.plates.count > 0
    }

    emit {
        # Plate motion derived from mantle flow
        let flow_factor = signal.mantle.flow_strength * config.fracture.tectonics.derive_motion.flow_coupling in

        # Update tectonic activity based on flow-induced motion
        signal.tectonics.activity <- flow_factor * 0.1
        signal.plates.boundary_shear <- flow_factor * 1e-3
    }
}

# -----------------------------------------------------------------------------
# Cross-Domain Coupling: Stellar → Geophysics
# -----------------------------------------------------------------------------

# Tidal heating coupling: adds tidal power to thermal budget
# Connects stellar domain's computed tidal heating (from moons and companion stars)
# to the planetary thermal budget. Enables moons like Io to drive extreme volcanism.
# Tidal power is treated as additional heat input to the mantle alongside
# radiogenic and core heat sources.
fracture geophysics.stellar_tidal_coupling {
    : strata(thermal)

    when {
        # Active when stellar domain provides tidal power
        signal.stellar.total_tidal_power > 0.01 <W>
    }

    emit {
        # Add tidal power to core heat power (which feeds mantle heat via dt.integrate)
        # This couples tidal dissipation into the continuous thermal budget.
        # Assumes 100% efficiency: all tidal work dissipates as heat.
        signal.core.heat_power <- signal.stellar.total_tidal_power
    }
}

# =============================================================================
# Geophysics Fields (Observer Data)
# =============================================================================

field elevation.map {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Elevation Map")

    measure {
        signal.crust.elevation
    }
}

field thickness.map {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Thickness Map")

    measure {
        signal.crust.thickness
    }
}

field thermal.core {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Core Temperature Field")

    measure {
        signal.core.temp
    }
}

field thermal.mantle {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Mantle Temperature Field")

    measure {
        signal.mantle.temp
    }
}

field pressure.crustal {
    : Scalar<kg/m/s²>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Pressure Field")

    measure {
        signal.crust.pressure_base
    }
}

field stress.boundary {
    : Scalar<N/m²>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Boundary Stress Field")

    measure {
        signal.tectonics.boundary_stress
    }
}

field topography.dynamic {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Dynamic Topography Field")

    measure {
        signal.topography.dynamic_offset
    }
}

field isostasy.elevation_field {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Isostatic Elevation Field")

    measure {
        signal.isostasy.elevation
    }
}

field density.crustal {
    : Scalar<kg/m³>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Density Field")

    measure {
        signal.crust.density
    }
}

field thermal.heat_flow {
    : Scalar<W/m²>
    : strata(thermal)
    : topology(point_cloud)
    : title("Surface Heat Flow Field")

    measure {
        signal.surface.heat_flow
    }
}

field plates.velocity_map {
    : Scalar<m/s>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Plate Velocity Field")

    measure {
        signal.plates.mean_velocity
    }
}

field plates.boundary_shear_map {
    : Scalar<m/s>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Plate Boundary Shear Field")

    measure {
        signal.plates.boundary_shear
    }
}

field plates.age_map {
    : Scalar<Myr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Mean Plate Age Field")

    measure {
        signal.plates.mean_age
    }
}

field mantle.rayleigh {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Rayleigh Number Field")

    measure {
        signal.mantle.rayleigh_number
    }
}

field mantle.flow {
    : Scalar<cm/yr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Mantle Flow Strength Field")

    measure {
        signal.mantle.flow_strength
    }
}

field tectonics.orogeny {
    : Scalar<m/Myr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Orogeny Rate Field")

    measure {
        signal.tectonics.orogeny_rate
    }
}

field tectonics.volcanism_map {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Volcanism Index Field")

    measure {
        signal.tectonics.volcanism
    }
}

field tectonics.subduction {
    : Scalar<km²/Myr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Subduction Rate Field")

    measure {
        signal.tectonics.subduction_rate
    }
}

field tectonics.spreading {
    : Scalar<km²/Myr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Seafloor Spreading Field")

    measure {
        signal.tectonics.spreading_rate
    }
}

field plates.count_map {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Plate Count Field")

    measure {
        signal.plates.count
    }
}

field tectonics.activity_map {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Tectonic Activity Field")

    measure {
        signal.tectonics.activity
    }
}

field plates.divergent_activity_map {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Divergent Boundary Activity Field")

    measure {
        signal.plates.divergent_activity
    }
}

field plates.convergent_activity_map {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Convergent Boundary Activity Field")

    measure {
        signal.plates.convergent_activity
    }
}

field plates.transform_activity_map {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Transform Boundary Activity Field")

    measure {
        signal.plates.transform_activity
    }
}

field mantle.viscosity_map {
    : Scalar<Pa*s>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Mantle Viscosity Field")

    measure {
        signal.mantle.viscosity
    }
}

field mantle.convection_cells_map {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Convection Cell Count Field")

    measure {
        signal.mantle.convection_cells
    }
}

# =============================================================================
# Geophysics Impulses
# =============================================================================
# External causal inputs that influence geophysics state.
# These are emitted by fractures or external systems and applied during
# the Collect phase.

# -----------------------------------------------------------------------------
# Plate Collision Impulse
# -----------------------------------------------------------------------------
# Triggered when two tectonic plates collide, representing a contact event
# that affects plate dynamics and can trigger seismic/orogenic effects.

type PlateCollisionPayload {
    plate_a: Scalar<1>           # First plate ID
    plate_b: Scalar<1>           # Second plate ID
    energy: Scalar<J>            # Collision energy
}

/// External impulse representing a collision event between two tectonic plates.
/// Collision energy drives orogeny (mountain building) and increases volcanic activity
/// in convergent zones. Energy is distributed to crustal deformation and seismic release.
impulse tectonics.plate_collision {
    : PlateCollisionPayload
    : title("Plate Collision")
    : symbol("×")

    config {
        # Energy transfer efficiency to orogeny
        orogeny_efficiency: 0.3
        # Energy transfer to seismic activity
        seismic_efficiency: 0.1
        # Minimum energy threshold for significant effects
        min_significant_energy_j: 1.0e18
    }

    apply {
        # Only process collisions above threshold
        if payload.energy > config.impulse.tectonics.plate_collision.min_significant_energy_j {
            # Collision energy contributes to mountain building rate (m/Myr)
            # Scale: 1e21 J collision -> ~300 m/Myr orogeny boost
            let orogeny_contribution =
                payload.energy * config.impulse.tectonics.plate_collision.orogeny_efficiency
                / 1.0e18 in

            signal.tectonics.orogeny_rate <- orogeny_contribution;

            # Collision energy also increases volcanic activity in collision zones
            let activity_boost = payload.energy / 1.0e22 in
            signal.tectonics.activity <- activity_boost
        }
    }
}

# -----------------------------------------------------------------------------
# Volcanic Impulse
# -----------------------------------------------------------------------------
# Deterministic volcanic venting tied to crustal tension and hydration.
# Deposits heat, releases volatiles, and adds ejecta to the surface.

type VolcanicImpulsePayload {
    index: Scalar<1>             # Crust sample index where impulse originates
    shell: Scalar<1>             # Shell index affected (0 = surface)
    heat_j: Scalar<J>            # Heat deposited into the shell
    volatiles: Scalar<1>         # Volatile release magnitude (arbitrary units)
    ejecta_thickness_m: Scalar<m> # Local crustal thickening from deposits
}

/// External volcanic event impulse. Injects heat into crustal shells, releases volatiles
/// into atmosphere (primarily CO2), and deposits ejecta to increase local crustal thickness.
/// Triggered by magma chamber pressure buildup or tectonic fracturing.
impulse tectonics.volcanic {
    : VolcanicImpulsePayload
    : title("Volcanic Impulse")
    : symbol("🌋")

    config {
        # Volatile to CO2 conversion factor
        volatile_to_co2_factor: 0.1
        # Heat transfer efficiency to surface
        surface_heat_efficiency: 0.5
        # Minimum heat for significant eruption
        min_eruption_heat_j: 1.0e12
    }

    apply {
        if payload.heat_j > config.impulse.tectonics.volcanic.min_eruption_heat_j {
            # Heat deposited increases local thermal budget
            let surface_heat =
                payload.heat_j * config.impulse.tectonics.volcanic.surface_heat_efficiency in
            signal.thermal.surface_flux <- surface_heat / 1.0e18;

            # NOTE: CO2 release disabled - at geological timescales, CO2 is handled
            # by equilibrium dynamics in atmosphere.co2_equilibrium fracture
            # Individual eruptions are insignificant vs long-term volcanic degassing

            # Volcanic activity index boost
            signal.tectonics.volcanism <- payload.volatiles / 10.0;

            # Ejecta contributes to crustal thickening signal
            signal.crust.thickness <- payload.ejecta_thickness_m
        }
    }
}

# =============================================================================
# Geophysics Chronicles
# =============================================================================

# Supercontinent formation: plates merge into unified landmass
chronicle geophysics.events.supercontinent_formation {
    observe {
        when signal.plates.continental_count < 3 &&
             signal.plates.total_buoyancy > 0.6 * signal.plates.count {
            emit event.supercontinent_formation {
                plate_count: signal.plates.count
                continental_count: signal.plates.continental_count
                mean_thickness: signal.plates.mean_thickness
                boundary_stress: signal.tectonics.boundary_stress
                severity: "major"
                description: "Supercontinent formation - continental plates unified"
            }
        }
    }
}

# Supercontinent breakup: rapid plate fragmentation
chronicle geophysics.events.supercontinent_breakup {
    observe {
        when signal.plates.count > 20 &&
             signal.tectonics.boundary_stress > 5.0e8 &&
             signal.mantle.flow_strength > 7.0 {
            emit event.supercontinent_breakup {
                plate_count: signal.plates.count
                boundary_stress: signal.tectonics.boundary_stress
                flow_strength: signal.mantle.flow_strength
                spreading_rate: signal.tectonics.spreading_rate
                severity: "major"
                description: "Supercontinent breakup - rifting and fragmentation"
            }
        }
    }
}

# Major volcanic eruption: extreme volcanism event
chronicle geophysics.events.major_volcanic_eruption {
    observe {
        when signal.tectonics.volcanism > 50.0 &&
             signal.mantle.temp > 1800.0 <K> {
            emit event.major_volcanic_eruption {
                volcanism_index: signal.tectonics.volcanism
                mantle_temp: signal.mantle.temp
                core_heat_power: signal.core.heat_power
                surface_heat_flow: signal.surface.heat_flow
                severity: "major"
                description: "Major volcanic eruption - extreme tectonic activity"
            }
        }
    }
}

# Planetary cooling milestone: core temperature drops below threshold
chronicle geophysics.events.planetary_cooling {
    observe {
        when signal.core.temp < 3000.0 <K> {
            emit event.planetary_cooling {
                core_temp: signal.core.temp
                mantle_temp: signal.mantle.temp
                heat_power: signal.core.heat_power
                tectonic_activity: signal.tectonics.activity
                severity: "major"
                description: "Planetary cooling - thermal evolution milestone"
            }
        }
    }
}

# Tectonic stagnation: plate motion ceases
chronicle geophysics.events.tectonic_stagnation {
    observe {
        when signal.tectonics.activity < 0.1 &&
             signal.plates.mean_velocity < 0.001 {
            emit event.tectonic_stagnation {
                activity: signal.tectonics.activity
                mean_velocity: signal.plates.mean_velocity
                core_temp: signal.core.temp
                mantle_temp: signal.mantle.temp
                severity: "critical"
                description: "Tectonic stagnation - plate motion ceased"
            }
        }
    }
}

# Mountain building event: extreme orogeny
chronicle geophysics.events.mountain_building {
    observe {
        when signal.crust.elevation > 7000.0 &&
             signal.tectonics.orogeny_rate > 5000.0 {
            emit event.mountain_building {
                elevation: signal.crust.elevation
                orogeny_rate: signal.tectonics.orogeny_rate
                crust_thickness: signal.crust.thickness
                boundary_stress: signal.tectonics.boundary_stress
                severity: "moderate"
                description: "Mountain building - extreme orogenic uplift"
            }
        }
    }
}
