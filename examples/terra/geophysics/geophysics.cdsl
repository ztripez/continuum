# Terra Geophysics Module
# Core planetary physics: gravity, rotation, thermal dynamics, and tectonics
#
# This module provides the foundational geophysical signals that other
# modules (atmosphere, hydrology, ecology) depend on.
# =============================================================================

# =============================================================================
# Geophysics Functions
# =============================================================================

# Compute isostatic buoyancy factor from density contrast
fn.isostasy.buoyancy_factor(crustal_density, mantle_density) {
    1.0 - crustal_density / mantle_density
}

# Compute isostatic elevation from thickness, factor, and reference level
fn.isostasy.compute_elevation(thickness, factor, reference_level) {
    factor * thickness - reference_level
}

# Compute lithostatic pressure at depth
fn.pressure.lithostatic(surface_pressure, density, gravity, depth) {
    surface_pressure + density * gravity * depth
}

# Compute geothermal temperature at depth
fn.thermal.geothermal_temp(surface_temp, gradient, depth_km) {
    surface_temp + gradient * depth_km
}

# =============================================================================
# Geophysics Constants
# =============================================================================

const {
    # Fundamental physics
    physics.gravitational: 6.67430e-11
    physics.stefan_boltzmann: 5.67e-8

    # Earth reference values
    earth.mass: 5.972e24
    earth.radius: 6.371e6
    earth.gravity: 9.80665
    earth.gravitational_parameter: 3.986e14

    # Crust properties
    crust.density_continental: 2700.0
    crust.density_oceanic: 2900.0
    mantle.density: 3300.0

    # Isostasy
    isostasy.reference_thickness: 35000.0

    # Dynamic topography
    topography.max_plume_uplift: 2000.0
    topography.max_slab_depression: 1000.0

    # Thermal
    thermal.surface_temp: 288.0
    thermal.gradient: 25.0
    thermal.mantle_temp: 1600.0

    # Radiogenic decay
    thermal.radiogenic_halflife_gyr: 2.5

    # Rotation
    rotation.earth_omega: 7.292e-5
}

# =============================================================================
# Geophysics Configuration
# =============================================================================

config {
    # Planet parameters
    planet.mass: 5.972e24
    planet.radius: 6.371e6

    # Crust configuration
    crust.initial_thickness: 35000.0
    crust.min_thickness: 3000.0
    crust.max_thickness: 80000.0
    crust.density: 2700.0

    # Isostasy configuration
    isostasy.crustal_density: 2700.0
    isostasy.mantle_density: 3300.0

    # Topography
    topography.flow_coupling: 1.0
    elevation.max_depth: 11000.0
    elevation.max_height: 9000.0

    # Thermal
    thermal.decay_halflife: 4.5e17 <s>
    thermal.surface_heat_flow: 0.065
    thermal.conductivity: 2.5

    # Initial values
    core.initial_temp: 5500.0
    mantle.initial_temp: 1600.0
    surface.initial_temp: 288.0
    surface.initial_heat_flow: 0.065
    crust.initial_density: 2700.0
    crust.initial_elevation: 0.0
    crust.initial_pressure_base: 1e9
    crust.initial_temp_base: 1163.0
    crust.initial_moho_depth: 35000.0
    isostasy.initial_factor: 0.182
    isostasy.initial_reference_level: 6370.0
    isostasy.initial_elevation: 0.0
    topography.initial_dynamic_offset: 0.0
    tectonics.initial_boundary_stress: 0.0
    planet.initial_radius: 6.371e6
    planet.initial_mass: 5.972e24
    planet.initial_gravity_mu: 3.986e14
    planet.initial_surface_gravity: 9.81

    # Rotation initial values
    rotation.initial_phase: 0.0
    rotation.initial_omega: 7.292e-5
    spin.initial_obliquity: 0.409
    spin.initial_precession: 0.0

    # Mantle flow
    mantle.initial_heat_content: 8.0e30
    core.initial_heat_power: 4.0e13

    # Tectonic activity
    tectonics.initial_activity: 1.0
    tectonics.reference_shear: 30.0
    tectonics.initial_plate_count: 12

    # Plate entity configuration
    plates.count: 12
    plates.min_count: 5
    plates.max_count: 50
    plates.oceanic_fraction: 0.71
    plates.max_oceanic_age_myr: 280.0
    plates.age_min_myr: 0.0
    plates.age_max_myr: 4000.0
    plates.thickness_min_m: 5000.0
    plates.thickness_max_m: 70000.0
    plates.continental_thickness_threshold_m: 30000.0
    plates.buoyancy_min: 0.0
    plates.buoyancy_max: 1.0
    plates.continental_buoyancy_threshold: 0.5
}

# =============================================================================
# Core Planetary Signals
# =============================================================================

signal.planet.radius {
    : Scalar<m, 1e6..1e8>
    : strata(genesis)
    : title("Planet Radius")
    : symbol("R")

    resolve {
        config.planet.radius
    }

    assert {
        prev >= 1e6 : fatal, "Planet radius below minimum"
        prev <= 1e8 : fatal, "Planet radius above maximum"
    }
}

signal.planet.mass {
    : Scalar<kg, 1e22..1e28>
    : strata(genesis)
    : title("Planet Mass")
    : symbol("M")

    resolve {
        config.planet.mass
    }

    assert {
        prev >= 1e22 : fatal, "Planet mass below minimum"
        prev <= 1e28 : fatal, "Planet mass above maximum"
    }
}

# Gravitational parameter mu = G * M
signal.planet.gravity_mu {
    : Scalar<m³/s², 1e12..1e18>
    : strata(genesis)
    : title("Gravitational Parameter")
    : symbol("mu")

    resolve {
        const.physics.gravitational * signal.planet.mass
    }

    assert {
        prev >= 1e12 : fatal, "Gravitational parameter below minimum"
        prev <= 1e18 : fatal, "Gravitational parameter above maximum"
    }
}

# Surface gravity g = mu / R^2
signal.planet.surface_gravity {
    : Scalar<m/s², 1..50>
    : strata(genesis)
    : title("Surface Gravity")
    : symbol("g")

    resolve {
        signal.planet.gravity_mu / (signal.planet.radius * signal.planet.radius)
    }

    assert {
        prev >= 1.0 : warn, "Surface gravity unusually low"
        prev <= 50.0 : warn, "Surface gravity unusually high"
    }
}

# =============================================================================
# Rotation Signals (from old geophysics/signals.rs)
# =============================================================================

# Rotation state: phase and angular velocity
signal.rotation.state {
    : Vec2<rad>
    : strata(rotation)
    : title("Rotation State")
    : symbol("theta,omega")
    : uses(dt_raw)

    config {
        initial_phase: 0.0
        initial_omega: 7.292e-5
    }

    resolve {
        # Phase advances with angular velocity
        # phase += omega * dt
        let phase = prev.x + prev.y * dt_raw in
        let omega = prev.y + collected in
        vec2(mod(phase, 6.283185307), omega)
    }

    assert {
        prev.y >= 0.0 : warn, "Angular velocity should be non-negative"
        prev.y <= 1e-3 : warn, "Angular velocity exceeds physical limits"
    }
}

# Axial obliquity (tilt angle from ecliptic normal)
# Earth: ~23.4 degrees = 0.409 rad
signal.rotation.obliquity {
    : Scalar<rad, 0..PI>
    : strata(rotation)
    : title("Axial Obliquity")
    : symbol("epsilon")
    : uses(dt_raw)

    config {
        initial: 0.409
        precession_rate: 0.0  # rad/s, can evolve via tidal effects
    }

    resolve {
        # Obliquity can evolve due to tidal torques and perturbations
        prev + collected
    }

    assert {
        prev >= 0.0 : warn, "Obliquity cannot be negative"
        prev <= PI : warn, "Obliquity cannot exceed PI"
    }
}

# Precession angle (rotation of spin axis around ecliptic normal)
# Earth: completes one cycle in ~26,000 years
signal.rotation.precession {
    : Scalar<rad, 0..TAU>
    : strata(rotation)
    : title("Precession Angle")
    : symbol("psi")
    : uses(dt_raw)

    config {
        initial: 0.0
        rate: 7.7e-12  # rad/s, ~26,000 year period
    }

    resolve {
        # Precession advances at a rate determined by torques
        wrap(prev + config.rotation.precession.rate * dt_raw + collected, 0.0, TAU)
    }

    assert {
        prev >= 0.0 : warn, "Precession angle cannot be negative"
        prev <= TAU : warn, "Precession angle cannot exceed TAU"
    }
}

# Spin axis in world coordinates (computed from obliquity and precession)
# +Y is ecliptic normal, spin axis tilts from +Y by obliquity
signal.rotation.spin_axis {
    : Vec3<1>
    : strata(rotation)
    : title("Spin Axis World")
    : symbol("n_spin")

    resolve {
        # Compute unit vector from spherical angles
        # obliquity = angle from +Y axis
        # precession = rotation around Y axis in XZ plane
        let obl = signal.rotation.obliquity in
        let prec = signal.rotation.precession in
        let sin_obl = sin(obl) in
        let cos_obl = cos(obl) in
        vec3(
            sin_obl * sin(prec),   # x component
            cos_obl,               # y component (ecliptic normal)
            sin_obl * cos(prec)    # z component
        )
    }

    assert {
        abs(length(prev) - 1.0) < 0.01 : warn, "Spin axis should be unit vector"
    }
}

# =============================================================================
# Thermal Signals
# =============================================================================

signal.core.temp {
    : Scalar<K, 100..10000>
    : strata(thermal)
    : title("Core Temperature")
    : symbol("T_core")

    config {
        decay_halflife: 4.5e17 <s>
    }

    resolve {
        decay(prev, config.core.temp.decay_halflife) + collected
    }

    assert {
        prev >= 100 <K>
        prev <= 10000 <K>
        prev > 0 : fatal, "Core temperature must be positive"
    }
}

# Core heat power - net power from core to mantle
signal.core.heat_power {
    : Scalar<W, 0..1e15>
    : strata(thermal)
    : title("Core Heat Power")
    : symbol("P_core")

    config {
        initial_power: 4.0e13
        radiogenic_halflife_gyr: 2.5
    }

    resolve {
        # Radiogenic decay reduces heat production over time
        # Earth's core heat flow is ~2-6 TW
        decay(prev, config.core.heat_power.radiogenic_halflife_gyr * 3.1536e16) + collected
    }

    assert {
        prev >= 0.0 : warn, "Core heat power cannot be negative"
        prev <= 1e15 : warn, "Core heat power exceeds physical maximum"
    }
}

# Mantle heat content - thermal reservoir
signal.mantle.heat_content {
    : Scalar<J, 1e28..1e32>
    : strata(thermal)
    : title("Mantle Heat Content")
    : symbol("Q_mantle")
    : uses(dt_raw)

    config {
        initial_heat: 8.0e30
    }

    resolve {
        # Heat content changes with net power input: dQ/dt = P_in
        # Earth's mantle: mass ~4e24 kg, Cp ~1200 J/kg/K, T ~1600K = 8e30 J
        prev + signal.core.heat_power * dt_raw + collected
    }

    assert {
        prev >= 1e28 : warn, "Mantle heat content below minimum"
        prev <= 1e32 : warn, "Mantle heat content above maximum"
    }
}

signal.mantle.temp {
    : Scalar<K, 500..5000>
    : strata(thermal)
    : title("Mantle Temperature")

    config {
        core_coupling_factor: 0.01
        min_temp: 500.0
        max_temp: 5000.0
    }

    resolve {
        let core_coupling = (signal.core.temp - prev) * config.mantle.temp.core_coupling_factor in
        clamp(prev + core_coupling + collected, config.mantle.temp.min_temp, config.mantle.temp.max_temp)
    }

    assert {
        prev >= config.mantle.temp.min_temp : warn, "Mantle temperature below minimum"
        prev <= config.mantle.temp.max_temp : warn, "Mantle temperature above maximum"
    }
}

signal.surface.temp {
    : Scalar<K, 50..500>
    : strata(thermal)
    : title("Surface Temperature")

    const {
        geothermal_contribution: 0.875
    }

    resolve {
        const.thermal.surface_temp + const.surface.temp.geothermal_contribution + collected
    }

    assert {
        prev >= 50.0 : warn, "Surface temperature below habitable range"
        prev <= 500.0 : warn, "Surface temperature above habitable range"
    }
}

signal.surface.heat_flow {
    : Scalar<W/m², 0.01..0.5>
    : strata(thermal)
    : title("Surface Heat Flow")
    : symbol("q")

    config {
        baseline: 0.065
        conductivity: 2.5
    }

    resolve {
        let thermal_contribution = (signal.mantle.temp - signal.surface.temp) * 0.00001 in
        clamp(config.surface.heat_flow.baseline + thermal_contribution + collected, 0.01, 0.5)
    }

    assert {
        prev >= 0.01 : warn, "Heat flow below realistic minimum"
        prev <= 0.5 : warn, "Heat flow above realistic maximum"
    }
}

# =============================================================================
# Crust Signals - Isostasy Implementation
# =============================================================================

signal.crust.density {
    : Scalar<kg/m³, 2000..3500>
    : strata(tectonics)
    : title("Crustal Density")
    : symbol("rho_crust")

    config {
        continental: 2700.0
        oceanic: 2900.0
        min: 2000.0
        max: 3500.0
    }

    resolve {
        clamp(prev + collected, config.crust.density.min, config.crust.density.max)
    }

    assert {
        prev >= config.crust.density.min : warn, "Crustal density below minimum"
        prev <= config.crust.density.max : warn, "Crustal density above maximum"
    }
}

signal.crust.thickness {
    : Scalar<m, 3000..80000>
    : strata(tectonics)
    : title("Crustal Thickness")
    : symbol("h_crust")

    config {
        min: 3000.0
        max: 80000.0
    }

    resolve {
        clamp(prev + collected, config.crust.thickness.min, config.crust.thickness.max)
    }

    assert {
        prev >= config.crust.thickness.min : warn, "Crust thinning below minimum"
        prev <= config.crust.thickness.max : warn, "Crust thickening above maximum"
    }
}

signal.crust.total_thickness {
    : Scalar<m, 0..100000>
    : strata(tectonics)
    : title("Total Crustal Thickness")

    resolve {
        signal.crust.thickness
    }

    assert {
        prev >= 0.0 : warn, "Total thickness cannot be negative"
        prev <= 100000.0 : warn, "Total thickness exceeds maximum"
    }
}

# Isostatic factor: 1 - (crust_density / mantle_density)
signal.isostasy.factor {
    : Scalar<1, 0..1>
    : strata(tectonics)
    : title("Isostatic Factor")

    config {
        crustal_density: 2700.0
        mantle_density: 3300.0
    }

    resolve {
        isostasy.buoyancy_factor(config.isostasy.factor.crustal_density, config.isostasy.factor.mantle_density)
    }

    assert {
        prev >= 0.0 : warn, "Isostatic factor cannot be negative"
        prev <= 1.0 : warn, "Isostatic factor cannot exceed 1"
    }
}

signal.isostasy.reference_level {
    : Scalar<m, 0..10000>
    : strata(tectonics)
    : title("Isostatic Reference Level")

    resolve {
        signal.isostasy.factor * const.isostasy.reference_thickness
    }

    assert {
        prev >= 0.0 : warn, "Reference level cannot be negative"
        prev <= 10000.0 : warn, "Reference level exceeds maximum"
    }
}

signal.isostasy.elevation {
    : Scalar<m, -15000..15000>
    : strata(tectonics)
    : title("Isostatic Elevation")

    resolve {
        isostasy.compute_elevation(signal.crust.thickness, signal.isostasy.factor, signal.isostasy.reference_level)
    }

    assert {
        prev >= -15000.0 : warn, "Isostatic elevation below minimum"
        prev <= 15000.0 : warn, "Isostatic elevation above maximum"
    }
}

# =============================================================================
# Dynamic Topography
# =============================================================================

signal.topography.dynamic_offset {
    : Scalar<m, -1200..2400>
    : strata(tectonics)
    : title("Dynamic Topography Offset")

    config {
        flow_coupling: 1.0
        uplift_scale: 0.01
    }

    resolve {
        let thermal_gradient = (signal.mantle.temp - const.thermal.mantle_temp) / 1000.0 in
        let uplift = thermal_gradient * const.topography.max_plume_uplift * config.topography.dynamic_offset.flow_coupling * config.topography.dynamic_offset.uplift_scale in
        clamp(
            prev + uplift + collected,
            -const.topography.max_slab_depression,
            const.topography.max_plume_uplift
        )
    }

    assert {
        prev >= -const.topography.max_slab_depression : warn, "Dynamic offset below slab depression limit"
        prev <= const.topography.max_plume_uplift : warn, "Dynamic offset above plume uplift limit"
    }
}

# =============================================================================
# Combined Elevation
# =============================================================================

signal.crust.elevation {
    : Scalar<m, -11000..9000>
    : strata(tectonics)
    : title("Surface Elevation")
    : symbol("h_elev")

    config {
        max_depth: 11000.0
        max_height: 9000.0
    }

    resolve {
        clamp(
            signal.isostasy.elevation + signal.topography.dynamic_offset + collected,
            -config.crust.elevation.max_depth,
            config.crust.elevation.max_height
        )
    }

    assert {
        prev >= -config.crust.elevation.max_depth : warn, "Elevation below maximum ocean depth"
        prev <= config.crust.elevation.max_height : warn, "Elevation above maximum mountain height"
    }
}

# =============================================================================
# Derived Crust Properties
# =============================================================================

signal.crust.pressure_base {
    : Scalar<kg/m/s², 1e5..3e9>
    : strata(tectonics)
    : title("Base Crustal Pressure")

    config {
        surface_pressure: 100000.0
        density: 2700.0
        min: 1e5
        max: 3e9
    }

    resolve {
        pressure.lithostatic(config.crust.pressure_base.surface_pressure, config.crust.pressure_base.density, signal.planet.surface_gravity, signal.crust.thickness)
    }

    assert {
        prev >= config.crust.pressure_base.min : warn, "Base pressure below minimum"
        prev <= config.crust.pressure_base.max : warn, "Base pressure above maximum"
    }
}

signal.crust.temp_base {
    : Scalar<K, 300..1500>
    : strata(thermal)
    : title("Base Crustal Temperature")

    resolve {
        thermal.geothermal_temp(const.thermal.surface_temp, const.thermal.gradient, signal.crust.thickness / 1000.0)
    }

    assert {
        prev >= 300.0 : warn, "Base temperature below minimum"
        prev <= 1500.0 : warn, "Base temperature above maximum"
    }
}

signal.crust.moho_depth {
    : Scalar<m, 3000..80000>
    : strata(tectonics)
    : title("Moho Depth")

    resolve {
        signal.crust.thickness
    }

    assert {
        prev >= 3000.0 : warn, "Moho depth below minimum crustal thickness"
        prev <= 80000.0 : warn, "Moho depth above maximum crustal thickness"
    }
}

# =============================================================================
# Tectonic Signals
# =============================================================================

signal.tectonics.boundary_stress {
    : Scalar<N/m², 0..1e9>
    : strata(tectonics)
    : title("Plate Boundary Stress")

    config {
        thermal_factor: 0.001
        thermal_scale: 1e4
        thickness_factor: 0.001
        thickness_scale: 1e3
        max_stress: 1e9
        reference_mantle_temp: 1600.0
    }

    resolve {
        let thermal_stress = abs(signal.mantle.temp - config.tectonics.boundary_stress.reference_mantle_temp) * config.tectonics.boundary_stress.thermal_scale * config.tectonics.boundary_stress.thermal_factor in
        let thickness_stress = abs(signal.crust.thickness - const.isostasy.reference_thickness) * config.tectonics.boundary_stress.thickness_scale * config.tectonics.boundary_stress.thickness_factor in
        clamp(prev + thermal_stress + thickness_stress + collected, 0.0, config.tectonics.boundary_stress.max_stress)
    }

    assert {
        prev >= 0.0 : warn, "Boundary stress cannot be negative"
        prev <= config.tectonics.boundary_stress.max_stress : warn, "Boundary stress exceeds maximum"
    }
}

# Tectonic activity index (from old signals.rs)
signal.tectonics.activity {
    : Scalar<1, 0..100>
    : strata(tectonics)
    : title("Tectonic Activity")
    : symbol("A_tec")

    config {
        reference_shear: 30.0
    }

    resolve {
        # Activity index normalized to 1.0 for Earth-like tectonics
        let raw_shear = collected in
        if raw_shear > 0.0 {
            raw_shear / config.tectonics.activity.reference_shear
        } else {
            prev
        }
    }

    assert {
        prev >= 0.0 : warn, "Tectonic activity cannot be negative"
        prev <= 100.0 : warn, "Tectonic activity exceeds maximum"
    }
}

# Plate count diagnostic (now derived from plate entity)
signal.tectonics.plate_count {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Plate Count")

    resolve {
        count(entity.terra.plate)
    }

    assert {
        prev >= 0.0 : warn, "Plate count cannot be negative"
        prev <= 64.0 : warn, "Plate count exceeds maximum"
    }
}

# Mantle viscosity diagnostic
signal.mantle.viscosity {
    : Scalar<Pa*s, 0..1e24>
    : strata(tectonics)
    : title("Mantle Viscosity")
    : symbol("eta")

    config {
        initial: 1e21  # Earth's effective mantle viscosity (Pa*s)
    }

    resolve {
        if prev == 0.0 {
            config.mantle.viscosity.initial + collected
        } else {
            prev + collected
        }
    }

    assert {
        prev >= 0.0 : warn, "Viscosity cannot be negative"
    }
}

# =============================================================================
# Mantle Convection Signals (from old mantle_flow.rs)
# =============================================================================

# Effective Rayleigh number - dimensionless measure of convection vigor
# Ra ~ Q/ν (heat power / viscosity) normalized to Earth-like conditions
signal.mantle.rayleigh_number {
    : Scalar<1, 0..1e10>
    : strata(tectonics)
    : title("Effective Rayleigh Number")
    : symbol("Ra")

    config {
        reference_heat_power: 4.0e13   # W (40 TW, Earth reference)
        reference_viscosity: 1.0e21    # Pa*s (Earth reference)
    }

    resolve {
        # Normalized Rayleigh: Ra_eff ~ (Q/Q_ref) / (ν/ν_ref)
        let q_norm = signal.core.heat_power / config.mantle.rayleigh_number.reference_heat_power in
        let nu_norm = signal.mantle.viscosity / config.mantle.rayleigh_number.reference_viscosity in
        if nu_norm > 0.0 {
            q_norm / nu_norm
        } else {
            1.0
        }
    }

    assert {
        prev >= 0.0 : warn, "Rayleigh number cannot be negative"
    }
}

# Convection cell count - derived from Rayleigh number
# More vigorous convection produces more cells
signal.mantle.convection_cells {
    : Scalar<1, 2..12>
    : strata(tectonics)
    : title("Convection Cell Count")
    : symbol("N_cells")

    config {
        reference_ra: 1.0e6            # Reference Rayleigh number
        mode_count: 4                  # Earth-like cell count
        exponent: 0.4                  # Scaling exponent
        min_count: 2
        max_count: 12
    }

    resolve {
        # n = mode * (Ra / Ra_ref)^exponent
        let ra = signal.mantle.rayleigh_number in
        let ratio = ra / config.mantle.convection_cells.reference_ra in
        let n = config.mantle.convection_cells.mode_count * pow(ratio, config.mantle.convection_cells.exponent) in
        clamp(n, config.mantle.convection_cells.min_count, config.mantle.convection_cells.max_count)
    }

    assert {
        prev >= 2.0 : warn, "Convection cells below minimum"
        prev <= 12.0 : warn, "Convection cells above maximum"
    }
}

# Mantle flow strength - vortex velocity scale (cm/yr)
# Higher heat power drives more vigorous convection
signal.mantle.flow_strength {
    : Scalar<cm/yr, 0..50>
    : strata(tectonics)
    : title("Mantle Flow Strength")
    : symbol("v_mantle")

    config {
        base_strength: 5.0             # cm/yr (typical Earth mantle)
        reference_heat_power: 4.0e13   # W
        exponent: 0.3                  # Strength scaling exponent
    }

    resolve {
        # strength ~ base * (Q/Q_ref)^exponent
        let ratio = signal.core.heat_power / config.mantle.flow_strength.reference_heat_power in
        let scale = pow(max(ratio, 0.0), config.mantle.flow_strength.exponent) in
        config.mantle.flow_strength.base_strength * scale + collected
    }

    assert {
        prev >= 0.0 : warn, "Flow strength cannot be negative"
    }
}

# =============================================================================
# Advanced Tectonic Signals
# =============================================================================

# Orogeny rate - rate of mountain building from plate collisions
signal.tectonics.orogeny_rate {
    : Scalar<m/Myr, 0..10000>
    : strata(tectonics)
    : title("Orogeny Rate")
    : symbol("dh/dt")

    config {
        stress_factor: 1e-8            # Conversion from stress to uplift rate
        activity_factor: 100.0         # Base rate per unit activity
    }

    resolve {
        # Orogeny driven by boundary stress and tectonic activity
        let stress_contribution = signal.tectonics.boundary_stress * config.tectonics.orogeny_rate.stress_factor in
        let activity_contribution = signal.tectonics.activity * config.tectonics.orogeny_rate.activity_factor in
        stress_contribution + activity_contribution + collected
    }

    assert {
        prev >= 0.0 : warn, "Orogeny rate cannot be negative"
    }
}

# Volcanism index - volcanic activity level from thermal state
signal.tectonics.volcanism {
    : Scalar<1, 0..100>
    : strata(tectonics)
    : title("Volcanism Index")
    : symbol("V_idx")

    config {
        reference_mantle_temp: 1600.0  # K
        temp_sensitivity: 0.01         # Index per K above reference
        flow_factor: 0.5               # Contribution from mantle flow
    }

    resolve {
        # Volcanism driven by excess mantle temperature and convection strength
        let temp_excess = max(signal.mantle.temp - config.tectonics.volcanism.reference_mantle_temp, 0.0) in
        let temp_contribution = temp_excess * config.tectonics.volcanism.temp_sensitivity in
        let flow_contribution = signal.mantle.flow_strength * config.tectonics.volcanism.flow_factor in
        clamp(temp_contribution + flow_contribution + collected, 0.0, 100.0)
    }

    assert {
        prev >= 0.0 : warn, "Volcanism index cannot be negative"
        prev <= 100.0 : warn, "Volcanism index exceeds maximum"
    }
}

# Subduction rate - rate at which oceanic crust is recycled
signal.tectonics.subduction_rate {
    : Scalar<km²/Myr, 0..10>
    : strata(tectonics)
    : title("Subduction Rate")
    : symbol("A_sub")

    config {
        velocity_factor: 1e-6          # Conversion from plate velocity
        boundary_factor: 0.1           # Factor for boundary length contribution
    }

    resolve {
        # Subduction rate driven by plate velocities and convergent boundaries
        let velocity_contribution = signal.plates.boundary_shear * 1e6 * config.tectonics.subduction_rate.velocity_factor in
        let oceanic_fraction = signal.plates.oceanic_count / max(signal.plates.count, 1.0) in
        velocity_contribution * oceanic_fraction * signal.tectonics.activity + collected
    }

    assert {
        prev >= 0.0 : warn, "Subduction rate cannot be negative"
    }
}

# Seafloor spreading rate - rate of new oceanic crust creation
signal.tectonics.spreading_rate {
    : Scalar<km²/Myr, 0..10>
    : strata(tectonics)
    : title("Seafloor Spreading Rate")
    : symbol("A_spread")

    config {
        mantle_coupling: 0.2           # Coupling to mantle flow
    }

    resolve {
        # Spreading rate roughly balances subduction over long timescales
        # Driven by mantle upwelling strength
        let flow_contribution = signal.mantle.flow_strength * config.tectonics.spreading_rate.mantle_coupling in
        let activity_contribution = signal.tectonics.activity in
        flow_contribution * activity_contribution + collected
    }

    assert {
        prev >= 0.0 : warn, "Spreading rate cannot be negative"
    }
}

# =============================================================================
# Tectonic Plate Entity
# =============================================================================

entity.terra.plate {
    : count(config.plates.count)
    : count(5..64)
}

# -----------------------------------------------------------------------------
# Plate Physical Properties
# -----------------------------------------------------------------------------

# Plate type: 0 = oceanic, 1 = continental
member.terra.plate.kind {
    : Scalar<1, 0..1>
    : strata(tectonics)
    : title("Plate Type")
    : symbol("k_plate")

    resolve { prev }
}

# Plate age in millions of years
# Oceanic plates age and eventually subduct; continental plates can be billions of years old
member.terra.plate.age {
    : Scalar<Myr, 0..5000>
    : strata(tectonics)
    : title("Plate Age")
    : symbol("t_plate")
    : uses(dt_raw)

    config {
        max_oceanic_age_myr: 280.0
    }

    resolve {
        # Plates age with simulation time
        # Oceanic plates are capped at max age (subduction recycling)
        let new_age = prev + dt_raw / 3.1536e13 in  # Convert seconds to Myr
        if self.kind < 0.5 {
            # Oceanic: cap at max age
            min(new_age, config.terra.plate.age.max_oceanic_age_myr)
        } else {
            # Continental: no cap
            new_age
        }
    }

    assert {
        prev >= 0.0 : warn, "Plate age cannot be negative"
    }
}

# Plate lithosphere thickness
member.terra.plate.thickness {
    : Scalar<m, 5000..70000>
    : strata(tectonics)
    : title("Plate Thickness")
    : symbol("h_plate")

    resolve {
        clamp(prev + collected, 5000.0, 70000.0)
    }

    assert {
        prev >= 5000.0 : warn, "Plate thickness below minimum"
        prev <= 70000.0 : warn, "Plate thickness above maximum"
    }
}

# Plate buoyancy (0 = dense/subductable, 1 = buoyant/resistant)
# Lower buoyancy = more likely to subduct
member.terra.plate.buoyancy {
    : Scalar<1, 0..1>
    : strata(tectonics)
    : title("Plate Buoyancy")
    : symbol("b_plate")

    resolve {
        clamp(prev + collected, 0.0, 1.0)
    }

    assert {
        prev >= 0.0 : warn, "Plate buoyancy cannot be negative"
        prev <= 1.0 : warn, "Plate buoyancy cannot exceed 1"
    }
}

# -----------------------------------------------------------------------------
# Plate Geometry (seed direction on sphere)
# -----------------------------------------------------------------------------

# Plate seed direction in body frame (unit vector defining plate center)
member.terra.plate.seed_direction {
    : Vec3<1>
    : strata(tectonics)
    : title("Plate Seed Direction")
    : symbol("n_plate")

    resolve {
        # Normalize to maintain unit vector
        normalize(prev)
    }

    assert {
        abs(length(prev) - 1.0) < 0.01 : warn, "Plate seed should be unit vector"
    }
}

# -----------------------------------------------------------------------------
# Plate Kinematics
# -----------------------------------------------------------------------------

# Plate angular velocity (rotation axis and rate in body frame)
member.terra.plate.omega {
    : Vec3<rad/s>
    : strata(tectonics)
    : title("Plate Angular Velocity")
    : symbol("omega_plate")

    config {
        scale: 1.0
    }

    resolve {
        # Plate motion derived from mantle flow and collected impulses
        config.terra.plate.omega.scale * (prev + collected)
    }
}

# Plate surface velocity magnitude at equator of rotation
member.terra.plate.velocity {
    : Scalar<m/s, 0..1>
    : strata(tectonics)
    : title("Plate Velocity")
    : symbol("v_plate")

    resolve {
        # v = omega * R (velocity at planet radius)
        length(self.omega) * signal.planet.radius
    }

    assert {
        prev >= 0.0 : warn, "Plate velocity cannot be negative"
    }
}

# -----------------------------------------------------------------------------
# Aggregate Plate Signals
# -----------------------------------------------------------------------------

# Number of plates (derived from entity count)
signal.plates.count {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Number of Plates")
    : symbol("N_plates")

    resolve {
        count(entity.terra.plate)
    }
}

# Mean plate age
signal.plates.mean_age {
    : Scalar<Myr, 0..5000>
    : strata(tectonics)
    : title("Mean Plate Age")
    : symbol("t_mean")

    resolve {
        mean(entity.terra.plate, self.age)
    }
}

# Mean plate thickness
signal.plates.mean_thickness {
    : Scalar<m, 5000..70000>
    : strata(tectonics)
    : title("Mean Plate Thickness")
    : symbol("h_mean")

    resolve {
        mean(entity.terra.plate, self.thickness)
    }
}

# Oceanic plate count
signal.plates.oceanic_count {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Oceanic Plate Count")
    : symbol("N_oceanic")

    resolve {
        sum(entity.terra.plate, if self.kind < 0.5 { 1.0 } else { 0.0 })
    }
}

# Continental plate count
signal.plates.continental_count {
    : Scalar<1, 0..64>
    : strata(tectonics)
    : title("Continental Plate Count")
    : symbol("N_continental")

    resolve {
        sum(entity.terra.plate, if self.kind >= 0.5 { 1.0 } else { 0.0 })
    }
}

# Maximum boundary shear (approximation from plate velocities)
signal.plates.boundary_shear {
    : Scalar<m/s, 0..1>
    : strata(tectonics)
    : title("Plate Boundary Shear")
    : symbol("tau_boundary")

    resolve {
        # Approximate shear as max velocity difference between plates
        let max_v = max(entity.terra.plate, self.velocity) in
        let min_v = min(entity.terra.plate, self.velocity) in
        max_v - min_v + collected
    }
}

# =============================================================================
# Geophysics Fractures (Tectonic Events)
# =============================================================================

# Rifting: thin crust + high stress -> rift opening
fracture.tectonics.rift {
    when {
        signal.crust.thickness < 25000
        signal.tectonics.boundary_stress > 5e8
    }

    emit {
        signal.tectonics.boundary_stress <- -signal.tectonics.boundary_stress * 0.8
        signal.crust.thickness <- -500.0
        signal.topography.dynamic_offset <- 200.0
    }
}

# Orogeny: thick crust + compression -> mountain building
fracture.tectonics.orogeny {
    when {
        signal.crust.thickness > 50000
        signal.tectonics.boundary_stress > 7e8
    }

    emit {
        signal.tectonics.boundary_stress <- -signal.tectonics.boundary_stress * 0.6
        signal.crust.thickness <- 1000.0
        signal.topography.dynamic_offset <- -100.0
    }
}

# Volcanism: hot mantle + thin crust -> volcanic activity
fracture.thermal.volcanism {
    when {
        signal.mantle.temp > 1800 <K>
        signal.crust.thickness < 30000
    }

    emit {
        signal.mantle.temp <- -50.0
        signal.crust.thickness <- 100.0
        signal.topography.dynamic_offset <- 50.0
    }
}

# Radioactive heating burst
fracture.core.decay_heat {
    when {
        signal.core.temp < 5000 <K>
    }

    emit {
        signal.core.temp <- 10.0
    }
}

# =============================================================================
# Geophysics Fields (Observer Data)
# =============================================================================

field.elevation.map {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Elevation Map")

    measure {
        signal.crust.elevation
    }
}

field.thickness.map {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Thickness Map")

    measure {
        signal.crust.thickness
    }
}

field.thermal.core {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Core Temperature Field")

    measure {
        signal.core.temp
    }
}

field.thermal.mantle {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Mantle Temperature Field")

    measure {
        signal.mantle.temp
    }
}

field.pressure.crustal {
    : Scalar<kg/m/s²>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Pressure Field")

    measure {
        signal.crust.pressure_base
    }
}

field.stress.boundary {
    : Scalar<N/m²>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Boundary Stress Field")

    measure {
        signal.tectonics.boundary_stress
    }
}

field.topography.dynamic {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Dynamic Topography Field")

    measure {
        signal.topography.dynamic_offset
    }
}

field.isostasy.elevation_field {
    : Scalar<m>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Isostatic Elevation Field")

    measure {
        signal.isostasy.elevation
    }
}

field.density.crustal {
    : Scalar<kg/m³>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Crustal Density Field")

    measure {
        signal.crust.density
    }
}

field.thermal.heat_flow {
    : Scalar<W/m²>
    : strata(thermal)
    : topology(point_cloud)
    : title("Surface Heat Flow Field")

    measure {
        signal.surface.heat_flow
    }
}

field.plates.velocity_map {
    : Scalar<m/s>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Plate Velocity Field")

    measure {
        signal.plates.boundary_shear
    }
}

field.plates.age_map {
    : Scalar<Myr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Mean Plate Age Field")

    measure {
        signal.plates.mean_age
    }
}

field.mantle.rayleigh {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Rayleigh Number Field")

    measure {
        signal.mantle.rayleigh_number
    }
}

field.mantle.flow {
    : Scalar<cm/yr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Mantle Flow Strength Field")

    measure {
        signal.mantle.flow_strength
    }
}

field.tectonics.orogeny {
    : Scalar<m/Myr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Orogeny Rate Field")

    measure {
        signal.tectonics.orogeny_rate
    }
}

field.tectonics.volcanism_map {
    : Scalar<1>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Volcanism Index Field")

    measure {
        signal.tectonics.volcanism
    }
}

field.tectonics.subduction {
    : Scalar<km²/Myr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Subduction Rate Field")

    measure {
        signal.tectonics.subduction_rate
    }
}

field.tectonics.spreading {
    : Scalar<km²/Myr>
    : strata(tectonics)
    : topology(point_cloud)
    : title("Seafloor Spreading Field")

    measure {
        signal.tectonics.spreading_rate
    }
}
