//! Minimal Thermal Simulation
//! A simple cooling simulation demonstrating the DSL and let expressions.

world.minimal {
    : title("Minimal Thermal Simulation")
    : version("0.1.0")
}

const {
    physics.stefan_boltzmann: 5.67e-8
    physics.boltzmann: 1.380649e-23
    thermal.ambient: 290.0
}

config {
    // Halflife in seconds (~4.5 billion years, like U-238)
    thermal.decay_halflife: 1.42e17 <s>
    thermal.initial_temp: 5500 <K>
    thermal.coupling_factor: 0.01
    thermal.radiation_factor: 0.0001
}

/// Thermal stratum for heat-related calculations.
strata.thermal {
    : title("Thermal")
    : symbol("Q")
    : stride(1)
}

/// Early cooling era with rapid heat loss.
era.early {
    : initial
    : title("Early Cooling")
    : dt(1 <Myr>)

    strata {
        thermal: active
    }

    transition {
        to: era.stable
        when {
            signal.core.temp < 4000 <K>
        }
    }
}

/// Stable era after initial cooling phase.
era.stable {
    : terminal
    : title("Stable")
    : dt(100 <kyr>)

    strata {
        thermal: active
    }
}

/// Core temperature signal tracking planetary interior heat.
/// Uses radioactive decay model for heat generation.
signal.core.temp {
    : Scalar<K, 100..10000>
    : strata(thermal)
    : title("Core Temperature")
    : symbol("T_core")

    resolve {
        // Demonstrating let expressions for readable multi-step calculations
        let decayed = decay(prev, config.thermal.decay_halflife) in
        let with_inputs = decayed + collected in
        with_inputs
    }

    assert {
        prev >= 100 <K>
        prev <= 10000 <K>
        prev > 0 : fatal, "temperature cannot be negative or zero"
    }
}

/// Surface temperature with heat transfer from core.
/// Models conductive heat transfer and radiative cooling to space.
signal.surface.temp {
    : Scalar<K, 100..1000>
    : strata(thermal)
    : title("Surface Temperature")
    : symbol("T_surf")

    resolve {
        // Heat transfer from core to surface using let for clarity
        let temp_diff = signal.core.temp - prev in
        let heat_transfer = temp_diff * config.thermal.coupling_factor in
        let radiation_loss = (prev - const.thermal.ambient) * config.thermal.radiation_factor in
        let new_temp = prev + heat_transfer - radiation_loss + collected in
        clamp(new_temp, 100.0, 1000.0)
    }
}

/// Temperature gradient between core and surface.
/// Useful for understanding heat flow dynamics.
signal.thermal.gradient {
    : Scalar<K, 0..10000>
    : strata(thermal)
    : title("Core-Surface Gradient")

    resolve {
        let core = signal.core.temp in
        let surface = signal.surface.temp in
        let gradient = core - surface in
        abs(gradient)
    }
}

/// Radioactive decay heat fracture.
/// Triggers when core temperature drops, simulating decay heat bursts.
fracture.core.decay_heat {
    when {
        signal.core.temp < 5498 <K>
    }

    emit {
        signal.core.temp <- 5.0
    }
}

/// Core temperature observation field.
field.core.temp_field {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Core Temperature Field")

    measure {
        signal.core.temp
    }
}

/// Surface temperature observation field.
field.surface.temp_field {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Surface Temperature Field")

    measure {
        signal.surface.temp
    }
}

/// Thermal gradient observation field.
field.thermal.gradient_field {
    : Scalar<K>
    : strata(thermal)
    : topology(point_cloud)
    : title("Thermal Gradient Field")

    measure {
        signal.thermal.gradient
    }
}

/// Chronicle for recording significant thermal events.
/// Chronicles are observer-only and cannot affect causality.
chronicle.thermal.events {
    observe {
        when signal.core.temp < 4500 {
            emit event.significant_cooling {
                core_temp: signal.core.temp
                surface_temp: signal.surface.temp
                gradient: signal.thermal.gradient
            }
        }

        when signal.surface.temp < 300 {
            emit event.surface_cooled {
                surface_temp: signal.surface.temp
            }
        }
    }
}
